{
  "name": "tooltip",
  "type": "registry:ui",
  "title": "Tooltip",
  "description": "A popup that displays information related to an element when the element receives keyboard focus or the mouse hovers over it.",
  "registryDependencies": [
    "@shadniwind/tokens",
    "@shadniwind/portal",
    "@shadniwind/positioning"
  ],
  "files": [
    {
      "path": "components/ui/tooltip.tsx",
      "content": "import * as React from \"react\"\nimport {\n  Platform,\n  Pressable,\n  type PressableProps,\n  Text,\n  View,\n  type ViewProps,\n} from \"react-native\"\nimport { StyleSheet } from \"react-native-unistyles\"\nimport { Portal } from \"../primitives/portal/index\"\nimport {\n  type Placement,\n  usePositioning,\n} from \"../primitives/positioning/index\"\n\nconst TOOLTIP_OPEN_DELAY = 700\n\ntype TooltipContextValue = {\n  open: boolean\n  onOpenChange: (open: boolean) => void\n  triggerRef: React.RefObject<View | null>\n  contentRef: React.RefObject<View | null>\n  contentId: string\n  delayDuration: number\n}\n\nconst TooltipContext = React.createContext<TooltipContextValue | undefined>(\n  undefined,\n)\n\nfunction useTooltip() {\n  const context = React.useContext(TooltipContext)\n  if (!context) {\n    throw new Error(\"useTooltip must be used within a Tooltip\")\n  }\n  return context\n}\n\nexport type TooltipProps = {\n  children: React.ReactNode\n  defaultOpen?: boolean\n  open?: boolean\n  onOpenChange?: (open: boolean) => void\n  delayDuration?: number\n}\n\nexport function Tooltip({\n  children,\n  defaultOpen = false,\n  open: openProp,\n  onOpenChange,\n  delayDuration = TOOLTIP_OPEN_DELAY,\n}: TooltipProps) {\n  const [open, setOpen] = React.useState(defaultOpen)\n  const triggerRef = React.useRef<View>(null)\n  const contentRef = React.useRef<View>(null)\n  const contentId = React.useId()\n\n  const isControlled = openProp !== undefined\n  const isOpen = isControlled ? openProp : open\n\n  const handleOpenChange = React.useCallback(\n    (newOpen: boolean) => {\n      if (!isControlled) {\n        setOpen(newOpen)\n      }\n      onOpenChange?.(newOpen)\n    },\n    [isControlled, onOpenChange],\n  )\n\n  return (\n    <TooltipContext.Provider\n      value={{\n        open: !!isOpen,\n        onOpenChange: handleOpenChange,\n        triggerRef,\n        contentRef,\n        contentId,\n        delayDuration,\n      }}\n    >\n      {children}\n    </TooltipContext.Provider>\n  )\n}\n\nexport const TooltipTrigger = React.forwardRef<\n  React.ComponentRef<typeof Pressable>,\n  PressableProps & { asChild?: boolean }\n>(\n  (\n    {\n      children,\n      asChild,\n      onPress,\n      onLongPress,\n      onPressIn,\n      onPressOut,\n      onHoverIn,\n      onHoverOut,\n      onFocus,\n      onBlur,\n      disabled,\n      ...props\n    },\n    ref,\n  ) => {\n    const { onOpenChange, triggerRef, delayDuration } = useTooltip()\n    const isDisabled = !!disabled\n    const timeoutRef = React.useRef<NodeJS.Timeout | undefined>(undefined)\n\n    const handleOpen = React.useCallback(() => {\n      if (isDisabled) return\n      clearTimeout(timeoutRef.current)\n      timeoutRef.current = setTimeout(() => {\n        onOpenChange(true)\n      }, delayDuration)\n    }, [delayDuration, isDisabled, onOpenChange])\n\n    const handleClose = React.useCallback(() => {\n      clearTimeout(timeoutRef.current)\n      onOpenChange(false)\n    }, [onOpenChange])\n\n    // Web: Hover and Focus\n    const handleHoverIn = React.useCallback(\n      (e: unknown) => {\n        if (Platform.OS === \"web\") {\n          handleOpen()\n        }\n        // @ts-expect-error - Web event type\n        onHoverIn?.(e)\n      },\n      [handleOpen, onHoverIn],\n    )\n\n    const handleHoverOut = React.useCallback(\n      (e: unknown) => {\n        if (Platform.OS === \"web\") {\n          handleClose()\n        }\n        // @ts-expect-error - Web event type\n        onHoverOut?.(e)\n      },\n      [handleClose, onHoverOut],\n    )\n\n    const handleFocus = React.useCallback(\n      (e: unknown) => {\n        if (Platform.OS === \"web\") {\n          handleOpen()\n        }\n        // @ts-expect-error - Web event type\n        onFocus?.(e)\n      },\n      [handleOpen, onFocus],\n    )\n\n    const handleBlur = React.useCallback(\n      (e: unknown) => {\n        if (Platform.OS === \"web\") {\n          handleClose()\n        }\n        // @ts-expect-error - Web event type\n        onBlur?.(e)\n      },\n      [handleClose, onBlur],\n    )\n\n    // Native: Long Press usually triggers tooltip, or press\n    // Native: Long Press usually triggers tooltip, or press\n    const handleLongPress = React.useCallback(\n      (e: unknown) => {\n        if (isDisabled) return\n        onOpenChange(true)\n        // @ts-expect-error - Event type mismatch\n        onLongPress?.(e)\n      },\n      [isDisabled, onOpenChange, onLongPress],\n    )\n\n    // Clean up timeout\n    React.useEffect(() => {\n      return () => clearTimeout(timeoutRef.current)\n    }, [])\n\n    // Sync ref\n    React.useEffect(() => {\n      if (ref) {\n        if (typeof ref === \"function\") {\n          ref(triggerRef.current)\n        } else {\n          ;(ref as { current: View | null }).current = triggerRef.current\n        }\n      }\n    }, [ref, triggerRef])\n\n    if (asChild && React.isValidElement(children)) {\n      // If asChild, we clone the child and add props.\n      // This is complex in RN if child is functional component without ref fwd.\n      // We will assume child accepts these props.\n\n      // We need to merge refs... simplified here: assume triggerRef is passed to cloning\n      // biome-ignore lint/suspicious/noExplicitAny: Cloning logic\n      return React.cloneElement(children as React.ReactElement<any>, {\n        ref: triggerRef,\n        onHoverIn: handleHoverIn,\n        onHoverOut: handleHoverOut,\n        onFocus: handleFocus,\n        onBlur: handleBlur,\n        onLongPress: handleLongPress,\n        disabled,\n        ...props, // merge other props\n      })\n    }\n\n    return (\n      <Pressable\n        ref={triggerRef}\n        onHoverIn={handleHoverIn}\n        onHoverOut={handleHoverOut}\n        onFocus={handleFocus}\n        onBlur={handleBlur}\n        onLongPress={handleLongPress}\n        disabled={disabled}\n        {...props}\n      >\n        {children}\n      </Pressable>\n    )\n  },\n)\n\nTooltipTrigger.displayName = \"TooltipTrigger\"\n\nexport type TooltipContentProps = ViewProps & {\n  side?: Placement\n  sideOffset?: number\n  align?: \"start\" | \"center\" | \"end\"\n  alignOffset?: number\n  avoidCollisions?: boolean\n}\n\nconst styles = StyleSheet.create((theme) => ({\n  content: {\n    zIndex: 50,\n    overflow: \"hidden\",\n    borderRadius: theme.radius.md,\n    borderWidth: 1,\n    borderColor: theme.colors.border,\n    backgroundColor: theme.colors.popover,\n    paddingHorizontal: 12, // px-3\n    paddingVertical: 6, // py-1.5\n    shadowColor: theme.colors.foreground, // shadow-md equiv?\n    shadowOpacity: 0.1,\n    shadowRadius: 4,\n    elevation: 2,\n  },\n  text: {\n    fontSize: theme.typography.sizes.sm,\n    color: theme.colors.popoverForeground,\n  },\n}))\n\nexport const TooltipContent = React.forwardRef<View, TooltipContentProps>(\n  (\n    {\n      children,\n      side = \"top\",\n      sideOffset = 4,\n      align = \"center\",\n      alignOffset = 0,\n      avoidCollisions = true,\n      style,\n      ...props\n    },\n    ref,\n  ) => {\n    const { open, triggerRef, contentRef } = useTooltip()\n\n    // Use positioning hook\n    const { position, isPositioned } = usePositioning({\n      anchorRef: triggerRef,\n      contentRef: contentRef,\n      placement: side,\n      offset: sideOffset,\n      alignOffset,\n      flip: avoidCollisions,\n      open, // only measure when open\n    })\n\n    // Sync ref\n    React.useEffect(() => {\n      if (ref) {\n        if (typeof ref === \"function\") {\n          ref(contentRef.current)\n        } else {\n          ;(ref as { current: View | null }).current = contentRef.current\n        }\n      }\n    }, [ref, contentRef])\n\n    if (!open) return null\n\n    // We render inside a Portal\n    return (\n      <Portal>\n        <View\n          ref={contentRef}\n          style={[\n            styles.content,\n            {\n              position: \"absolute\",\n              opacity: isPositioned ? 1 : 0, // Hide until positioned\n              top: position.top,\n              left: position.left,\n              // width? max-width?\n            },\n            style,\n          ]}\n          {...props}\n        >\n          {/* Wrap children in Text if they are strings, primitive style */}\n          {typeof children === \"string\" ? (\n            <Text style={styles.text}>{children}</Text>\n          ) : (\n            children\n          )}\n        </View>\n      </Portal>\n    )\n  },\n)\n\nTooltipContent.displayName = \"TooltipContent\"\n",
      "type": "registry:ui"
    }
  ]
}
