{
  "name": "roving-focus",
  "type": "registry:lib",
  "title": "Roving Focus",
  "description": "Roving Focus primitive for managing focus in a list or grid.",
  "files": [
    {
      "path": "lib/roving-focus/types.ts",
      "content": "import type { ViewProps } from \"react-native\"\n\n/**\n * Orientation of the focus navigation.\n */\nexport type Orientation = \"horizontal\" | \"vertical\" | \"both\"\n\n/**\n * Text direction for RTL languages.\n */\nexport type Direction = \"ltr\" | \"rtl\"\n\n/**\n * Props for the RovingFocusGroup container.\n * A RovingFocusGroup manages which of its children is focusable via the tab key.\n * Navigation between children is handled via arrow keys.\n */\nexport interface RovingFocusGroupProps extends ViewProps {\n  /**\n   * The orientation of the group. Defines which arrow keys trigger navigation.\n   * @default \"vertical\"\n   */\n  orientation?: Orientation\n\n  /**\n   * The reading direction of the group (for RTL support).\n   * @default \"ltr\"\n   */\n  dir?: Direction\n\n  /**\n   * Whether keyboard navigation should loop from the last item back to the first.\n   * @default false\n   */\n  loop?: boolean\n\n  /**\n   * The value of the currently focused item (controlled mode).\n   */\n  value?: string\n\n  /**\n   * The value of the item that should be focusable initially (uncontrolled mode).\n   */\n  defaultValue?: string\n\n  /**\n   * Event handler called when the focused item changes via keyboard navigation.\n   */\n  onValueChange?: (value: string) => void\n\n  /**\n   * If true, the component will merge its props onto its immediate child.\n   * @default false\n   */\n  asChild?: boolean\n}\n\n/**\n * Props for an item within a RovingFocusGroup.\n */\nexport interface RovingFocusItemProps extends ViewProps {\n  /**\n   * A unique identifier for this item. Used to track focus state in the group.\n   */\n  value: string\n\n  /**\n   * If true, the item will be skipped during keyboard navigation.\n   * @default false\n   */\n  disabled?: boolean\n\n  /**\n   * If true, the component will merge its props onto its immediate child.\n   * @default false\n   */\n  asChild?: boolean\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "lib/roving-focus/roving-focus.tsx",
      "content": "import { Platform } from \"react-native\"\nimport * as RovingFocusNative from \"./roving-focus.native\"\nimport * as RovingFocusWeb from \"./roving-focus.web\"\n\nexport const RovingFocusGroup =\n  Platform.OS === \"web\"\n    ? RovingFocusWeb.RovingFocusGroup\n    : RovingFocusNative.RovingFocusGroup\nexport const RovingFocusItem =\n  Platform.OS === \"web\"\n    ? RovingFocusWeb.RovingFocusItem\n    : RovingFocusNative.RovingFocusItem\n",
      "type": "registry:lib"
    },
    {
      "path": "lib/roving-focus/roving-focus.web.tsx",
      "content": "import * as React from \"react\"\nimport { View } from \"react-native\"\nimport type { RovingFocusGroupProps, RovingFocusItemProps } from \"./types\"\nimport { composeRefs } from \"./utils\"\n\n/**\n * Data attribute used to identify items within a roving focus group.\n */\nconst ITEM_DATA_ATTR = \"data-roving-focus-item\"\n/**\n * Data attribute used to store the unique value of an item.\n */\nconst VALUE_DATA_ATTR = \"data-roving-focus-value\"\n\nconst RovingFocusContext = React.createContext<{\n  value?: string\n  onValueChange: (value: string) => void\n  orientation?: \"horizontal\" | \"vertical\" | \"both\"\n  dir?: \"ltr\" | \"rtl\"\n  loop?: boolean\n} | null>(null)\n\n/**\n * Finds the next or previous item in a list of elements, optionally looping.\n * @private\n */\nfunction getNextItem(\n  current: HTMLElement,\n  items: HTMLElement[],\n  dir: \"next\" | \"prev\",\n  loop: boolean,\n): HTMLElement | null {\n  const index = items.indexOf(current)\n  if (index === -1) return null\n\n  let nextIndex = dir === \"next\" ? index + 1 : index - 1\n\n  if (loop) {\n    if (nextIndex < 0) nextIndex = items.length - 1\n    else if (nextIndex >= items.length) nextIndex = 0\n  }\n\n  // Clamp if not looping\n  if (nextIndex < 0 || nextIndex >= items.length) return null\n\n  return items[nextIndex]\n}\n\n/**\n * RovingFocusGroup (Web Implementation)\n * \n * **How it works:**\n * A Roving Focus group ensures that only one item in the list is part of the \n * tab order (`tabIndex=0`). All other items have `tabIndex=-1`. \n * Users navigate between items using arrow keys. When an item is focused, \n * it becomes the new \"focusable\" entry point.\n * \n * This implementation uses DOM queries and data attributes to manage focus \n * efficiently on the web without tracking every ref.\n */\nexport const RovingFocusGroup = React.forwardRef<View, RovingFocusGroupProps>(\n  (\n    {\n      orientation = \"vertical\",\n      dir = \"ltr\",\n      loop = false,\n      value: valueProp,\n      defaultValue,\n      onValueChange,\n      children,\n      style,\n      ...props\n    },\n    ref,\n  ) => {\n    const [value, setValue] = React.useState(valueProp ?? defaultValue)\n    const isControlled = valueProp !== undefined\n    const currentValue = isControlled ? valueProp : value\n\n    const handleValueChange = React.useCallback(\n      (newValue: string) => {\n        if (!isControlled) {\n          setValue(newValue)\n        }\n        onValueChange?.(newValue)\n      },\n      [isControlled, onValueChange],\n    )\n\n    /**\n     * Handles keyboard navigation (Arrow keys, Home, End).\n     */\n    const handleKeyDown = (e: React.KeyboardEvent) => {\n      const container = e.currentTarget as HTMLElement\n      const items = Array.from(\n        container.querySelectorAll(\n          `[${ITEM_DATA_ATTR}]:not([aria-disabled=\"true\"]):not([disabled])`,\n        ),\n      ) as HTMLElement[]\n\n      if (items.length === 0) return\n\n      const target = e.target as HTMLElement\n      const currentItem = target.closest(`[${ITEM_DATA_ATTR}]`) as HTMLElement\n\n      if (!currentItem) return\n\n      const isRtl = dir === \"rtl\"\n      const isVertical = orientation === \"vertical\" || orientation === \"both\"\n      const isHorizontal =\n        orientation === \"horizontal\" || orientation === \"both\"\n\n      let nextItem: HTMLElement | null = null\n\n      if (e.key === \"ArrowDown\" && isVertical) {\n        nextItem = getNextItem(currentItem, items, \"next\", loop)\n      } else if (e.key === \"ArrowUp\" && isVertical) {\n        nextItem = getNextItem(currentItem, items, \"prev\", loop)\n      } else if (e.key === \"ArrowRight\" && isHorizontal) {\n        nextItem = getNextItem(\n          currentItem,\n          items,\n          isRtl ? \"prev\" : \"next\",\n          loop,\n        )\n      } else if (e.key === \"ArrowLeft\" && isHorizontal) {\n        nextItem = getNextItem(\n          currentItem,\n          items,\n          isRtl ? \"next\" : \"prev\",\n          loop,\n        )\n      } else if (e.key === \"Home\") {\n        nextItem = items[0]\n      } else if (e.key === \"End\") {\n        nextItem = items[items.length - 1]\n      }\n\n      if (nextItem) {\n        e.preventDefault()\n        handleValueChange(nextItem.getAttribute(VALUE_DATA_ATTR) || \"\")\n        nextItem.focus()\n      }\n    }\n\n    const internalRef = React.useRef<HTMLElement | null>(null)\n    const setRef = React.useCallback(\n      (node: View | null) => {\n        internalRef.current = node as unknown as HTMLElement\n        if (typeof ref === \"function\") {\n          ref(node)\n        } else if (ref) {\n          ;(ref as { current: View | null }).current = node\n        }\n      },\n      [ref],\n    )\n\n    /**\n     * Set the initial focusable item if none is selected.\n     */\n    React.useEffect(() => {\n      if (currentValue !== undefined) return\n      const container = internalRef.current\n      if (!container) return\n\n      const items = Array.from(\n        container.querySelectorAll(\n          `[${ITEM_DATA_ATTR}]:not([aria-disabled=\"true\"]):not([disabled])`,\n        ),\n      ) as HTMLElement[]\n\n      if (items.length > 0) {\n        const firstItemValue = items[0].getAttribute(VALUE_DATA_ATTR)\n        if (firstItemValue) {\n          handleValueChange(firstItemValue)\n        }\n      }\n    }, [currentValue, handleValueChange])\n\n    return (\n      <RovingFocusContext.Provider\n        value={{\n          value: currentValue,\n          onValueChange: handleValueChange,\n          orientation,\n          dir,\n          loop,\n        }}\n      >\n        {/* @ts-expect-error: web-only prop */}\n        <View ref={setRef} onKeyDown={handleKeyDown} style={style} {...props}>\n          {children}\n        </View>\n      </RovingFocusContext.Provider>\n    )\n  },\n)\n\nRovingFocusGroup.displayName = \"RovingFocusGroup\"\n\n/**\n * RovingFocusItem (Web Implementation)\n * \n * An item within a RovingFocusGroup. It automatically manages its `tabIndex`\n * based on whether it is the currently active (selected) item in the group.\n */\nexport const RovingFocusItem = React.forwardRef<View, RovingFocusItemProps>(\n  ({ value, disabled, children, asChild, ...props }, ref) => {\n    const context = React.useContext(RovingFocusContext)\n    const isSelected = context?.value === value\n    const tabIndex = (isSelected ? 0 : -1) as 0 | -1\n\n    const itemRef = React.useRef<View>(null)\n    const composedRefs = composeRefs(ref, itemRef)\n\n    const commonProps = {\n      [ITEM_DATA_ATTR]: true,\n      [VALUE_DATA_ATTR]: value,\n      disabled, // Web prop\n      tabIndex: disabled ? undefined : tabIndex,\n      focusable: !disabled,\n      ...props,\n    }\n\n    if (asChild && React.isValidElement(children)) {\n      return React.cloneElement(children as React.ReactElement<{ ref: unknown }>, {\n        ref: composeRefs(composedRefs, (children as unknown as { ref: React.Ref<View> }).ref),\n        ...commonProps,\n      })\n    }\n\n    return (\n      <View\n        ref={composedRefs}\n        accessibilityRole=\"button\"\n        accessibilityState={{ disabled: !!disabled }}\n        {...commonProps}\n      >\n        {children}\n      </View>\n    )\n  },\n)\n\nRovingFocusItem.displayName = \"RovingFocusItem\"\n",
      "type": "registry:lib"
    },
    {
      "path": "lib/roving-focus/roving-focus.native.tsx",
      "content": "import * as React from \"react\"\nimport { View } from \"react-native\"\nimport type { RovingFocusGroupProps, RovingFocusItemProps } from \"./types\"\n\nexport const RovingFocusGroup = React.forwardRef<View, RovingFocusGroupProps>(\n  (props, ref) => {\n    return <View ref={ref} {...props} />\n  },\n)\nRovingFocusGroup.displayName = \"RovingFocusGroup\"\n\nexport const RovingFocusItem = React.forwardRef<View, RovingFocusItemProps>(\n  (props, ref) => {\n    return <View ref={ref} {...props} />\n  },\n)\nRovingFocusItem.displayName = \"RovingFocusItem\"\n",
      "type": "registry:lib"
    },
    {
      "path": "lib/roving-focus/index.ts",
      "content": "export * from \"./roving-focus\"\nexport * from \"./types\"\n",
      "type": "registry:lib"
    },
    {
      "path": "lib/roving-focus/utils.ts",
      "content": "import type * as React from \"react\"\n\nexport function composeRefs<T>(...refs: (React.Ref<T> | undefined)[]) {\n  return (node: T) => {\n    refs.forEach((ref) => {\n      if (typeof ref === \"function\") {\n        ref(node)\n      } else if (ref != null) {\n        ;(ref as React.MutableRefObject<T>).current = node\n      }\n    })\n  }\n}\n",
      "type": "registry:lib"
    }
  ]
}
