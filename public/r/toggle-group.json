{
  "name": "toggle-group",
  "type": "registry:ui",
  "title": "Toggle Group",
  "description": "A set of two-state buttons that can be toggled on or off.",
  "registryDependencies": [
    "tokens",
    "roving-focus",
    "toggle"
  ],
  "files": [
    {
      "path": "components/ui/toggle-group.tsx",
      "content": "import * as React from \"react\"\nimport { Platform, View, type ViewProps } from \"react-native\"\nimport { StyleSheet } from \"react-native-unistyles\"\nimport * as RovingFocusGroup from \"../primitives/roving-focus/index.js\"\nimport { Toggle, type ToggleProps } from \"./toggle.js\"\n\nconst ToggleGroupContext = React.createContext<{\n  size?: \"default\" | \"sm\" | \"lg\"\n  variant?: \"default\" | \"outline\"\n  rovingFocus?: boolean\n  disabled?: boolean\n}>({\n  size: \"default\",\n  variant: \"default\",\n  rovingFocus: true,\n  disabled: false,\n})\n\nexport type ToggleGroupType = \"single\" | \"multiple\"\n\nexport interface ToggleGroupProps extends ViewProps {\n  type: ToggleGroupType\n  value?: string | string[]\n  defaultValue?: string | string[]\n  onValueChange?: (value: string | string[]) => void // Type depends on 'type' prop really\n  disabled?: boolean\n  rovingFocus?: boolean\n  // Add variants or sizes if your Toggle supports them (our base Toggle is simple currently)\n}\n\nexport const ToggleGroup = React.forwardRef<View, ToggleGroupProps>(\n  (\n    {\n      type,\n      value: valueProp,\n      defaultValue,\n      onValueChange,\n      disabled = false,\n      rovingFocus = true,\n      children,\n      style,\n      ...props\n    },\n    ref,\n  ) => {\n    const [value, setValue] = React.useState<string | string[] | undefined>(\n      valueProp ?? defaultValue,\n    )\n\n    const isControlled = valueProp !== undefined\n    const currentValue = isControlled ? valueProp : value\n\n    const handleValueChange = React.useCallback(\n      (itemValue: string, pressed: boolean) => {\n        if (type === \"single\") {\n          const newValue = pressed ? itemValue : \"\" // Or undefined? usually empty string for single\n          // Single select: always one selected? or toggleable?\n          // Radix ToggleGroup single: unselecting is possible by default unless 'rovingFocus' implied?\n          // Usually single mode allows unselecting unless explicitly required.\n          if (!isControlled) setValue(newValue)\n          onValueChange?.(newValue)\n        } else {\n          // Multiple\n          const currentArray = (\n            Array.isArray(currentValue) ? currentValue : []\n          ) as string[]\n          let newArray: string[]\n          if (pressed) {\n            newArray = [...currentArray, itemValue]\n          } else {\n            newArray = currentArray.filter((v) => v !== itemValue)\n          }\n          if (!isControlled) setValue(newArray)\n          onValueChange?.(newArray)\n        }\n      },\n      [currentValue, isControlled, onValueChange, type],\n    )\n\n    const [focusValue, setFocusValue] = React.useState<string | undefined>(\n      type === \"single\" && typeof (valueProp ?? defaultValue) === \"string\"\n        ? ((valueProp ?? defaultValue) as string)\n        : undefined,\n    )\n\n    React.useEffect(() => {\n      if (type === \"single\" && typeof currentValue === \"string\") {\n        setFocusValue(currentValue)\n      }\n    }, [currentValue, type])\n\n    const handleItemToggle = React.useCallback(\n      (itemValue: string, pressed: boolean) => {\n        handleValueChange(itemValue, pressed)\n        setFocusValue(itemValue)\n      },\n      [handleValueChange],\n    )\n\n    const content = (\n      <View ref={ref} style={[styles.group, style]} {...props}>\n          {React.Children.map(children, (child) => {\n              if (React.isValidElement(child)) {\n                // We need to clone to pass toggle-group logic handling?\n                // Or proper context usage.\n                // We'll use Context so ToggleGroupItem can read state.\n                return child\n              }\n              return null\n            })}\n      </View>\n    )\n\n    // Context provider needs to expose state management for items to call context.toggle(itemValue)\n    // Actually, simple context with atomic actions is cleaner.\n\n    return (\n      <ToggleGroupHelperContext.Provider\n        value={{\n          value: currentValue,\n          onItemToggle: handleItemToggle,\n          type,\n          disabled,\n        }}\n      >\n        <ToggleGroupContext.Provider value={{ rovingFocus, disabled }}>\n          {Platform.OS === \"web\" && rovingFocus ? (\n            <RovingFocusGroup.RovingFocusGroup\n              orientation=\"horizontal\"\n              value={focusValue}\n              onValueChange={setFocusValue}\n              loop\n              asChild\n            >\n              {content}\n            </RovingFocusGroup.RovingFocusGroup>\n          ) : (\n            content\n          )}\n        </ToggleGroupContext.Provider>\n      </ToggleGroupHelperContext.Provider>\n    )\n  },\n)\n\nToggleGroup.displayName = \"ToggleGroup\"\n\nconst ToggleGroupHelperContext = React.createContext<{\n  value?: string | string[]\n  onItemToggle: (value: string, pressed: boolean) => void\n  type: ToggleGroupType\n  disabled?: boolean\n}>({\n  value: undefined,\n  onItemToggle: () => {},\n  type: \"single\",\n  disabled: false,\n})\n\nexport interface ToggleGroupItemProps extends ToggleProps {\n  value: string\n}\n\nexport const ToggleGroupItem = React.forwardRef<View, ToggleGroupItemProps>(\n  ({ value, disabled, ...props }, ref) => {\n    const context = React.useContext(ToggleGroupHelperContext)\n    const settings = React.useContext(ToggleGroupContext)\n\n    const isPressed = React.useMemo(() => {\n        if (context.type === \"single\") {\n            return context.value === value\n        }\n        if (Array.isArray(context.value)) {\n            return context.value.includes(value)\n        }\n        return false\n    }, [context.type, context.value, value])\n\n    const isDisabled = disabled || context.disabled || settings.disabled\n\n    const content = (\n      <Toggle\n        ref={ref}\n        pressed={isPressed}\n        onPressedChange={(pressed) => context.onItemToggle(value, pressed)}\n        disabled={isDisabled}\n        {...props}\n      />\n    )\n\n    if (Platform.OS === \"web\" && settings.rovingFocus) {\n      return (\n        <RovingFocusGroup.RovingFocusItem value={value} disabled={isDisabled} asChild>\n          {content}\n        </RovingFocusGroup.RovingFocusItem>\n      )\n    }\n\n    return content\n  },\n)\n\nToggleGroupItem.displayName = \"ToggleGroupItem\"\n\nconst styles = StyleSheet.create((theme) => ({\n  group: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: 4, // or -1 margin for connected look? Assuming separate buttons for now.\n  },\n}))\n",
      "type": "registry:ui"
    }
  ]
}
