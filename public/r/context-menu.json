{
  "name": "context-menu",
  "type": "registry:ui",
  "title": "Context Menu",
  "description": "Displays a context menu on right click or long press.",
  "registryDependencies": [
    "@shadniwind/tokens",
    "@shadniwind/portal",
    "@shadniwind/positioning",
    "@shadniwind/focus",
    "@shadniwind/overlay",
    "@shadniwind/roving-focus",
    "@shadniwind/press"
  ],
  "files": [
    {
      "path": "components/ui/context-menu.tsx",
      "content": "import * as React from \"react\"\nimport {\n  Platform,\n  Pressable,\n  type PressableProps,\n  ScrollView,\n  type ScrollViewProps,\n  type StyleProp,\n  Text,\n  type TextProps,\n  type TextStyle,\n  View,\n  type ViewProps,\n  type ViewStyle,\n} from \"react-native\"\nimport { StyleSheet, useUnistyles } from \"react-native-unistyles\"\n// @ts-expect-error - lucide-react-native is a peer dependency\nimport { Check, Circle } from \"lucide-react-native\"\nimport { FocusScope } from \"../primitives/focus/index\"\nimport { DismissLayer } from \"../primitives/overlay/index\"\nimport { Portal } from \"../primitives/portal/index\"\nimport {\n  type Placement,\n  usePositioning,\n} from \"../primitives/positioning/index\"\nimport { composeEventHandlers } from \"../primitives/press/index\"\nimport * as RovingFocusGroup from \"../primitives/roving-focus/index\"\n\ntype ContextMenuContextValue = {\n  open: boolean\n  onOpenChange: (open: boolean) => void\n  triggerRef: React.RefObject<View | null>\n  contentRef: React.RefObject<View | null>\n  modal: boolean\n  activeValue?: string\n  setActiveValue: (value?: string) => void\n  triggerId: string\n}\n\nconst ContextMenuContext = React.createContext<\n  ContextMenuContextValue | undefined\n>(undefined)\n\nfunction useContextMenu() {\n  const context = React.useContext(ContextMenuContext)\n  if (!context) {\n    throw new Error(\"ContextMenu components must be used within ContextMenu\")\n  }\n  return context\n}\n\nexport type ContextMenuProps = {\n  children: React.ReactNode\n  defaultOpen?: boolean\n  open?: boolean\n  onOpenChange?: (open: boolean) => void\n  modal?: boolean\n}\n\nexport function ContextMenu({\n  children,\n  defaultOpen = false,\n  open: openProp,\n  onOpenChange,\n  modal = false,\n}: ContextMenuProps) {\n  const [open, setOpen] = React.useState(defaultOpen)\n  const [activeValue, setActiveValue] = React.useState<string | undefined>(\n    undefined,\n  )\n  const triggerRef = React.useRef<View>(null)\n  const contentRef = React.useRef<View>(null)\n  const triggerId = React.useId()\n\n  const isControlled = openProp !== undefined\n  const currentOpen = isControlled ? openProp : open\n\n  const handleOpenChange = React.useCallback(\n    (nextOpen: boolean) => {\n      if (!isControlled) {\n        setOpen(nextOpen)\n      }\n      onOpenChange?.(nextOpen)\n    },\n    [isControlled, onOpenChange],\n  )\n\n  React.useEffect(() => {\n    if (!currentOpen) {\n      setActiveValue(undefined)\n    }\n  }, [currentOpen])\n\n  return (\n    <ContextMenuContext.Provider\n      value={{\n        open: !!currentOpen,\n        onOpenChange: handleOpenChange,\n        triggerRef,\n        contentRef,\n        modal,\n        activeValue,\n        setActiveValue,\n        triggerId,\n      }}\n    >\n      {children}\n    </ContextMenuContext.Provider>\n  )\n}\n\nexport type ContextMenuTriggerProps = PressableProps & {\n  asChild?: boolean\n  onContextMenu?: (event: unknown) => void\n  longPressDelay?: number\n}\n\nexport const ContextMenuTrigger = React.forwardRef<\n  React.ComponentRef<typeof Pressable>,\n  ContextMenuTriggerProps\n>(\n  (\n    { children, asChild, onContextMenu, onLongPress, disabled, longPressDelay, ...props },\n    ref,\n  ) => {\n    const { open, onOpenChange, triggerRef, triggerId } = useContextMenu()\n    const isDisabled = !!disabled\n\n    const handleContextMenu = React.useCallback(\n      (event: unknown) => {\n        if (isDisabled) return\n        if (Platform.OS === \"web\") {\n          ;(event as { preventDefault?: () => void }).preventDefault?.()\n        }\n        onOpenChange(true)\n        onContextMenu?.(event)\n      },\n      [isDisabled, onContextMenu, onOpenChange],\n    )\n\n    const handleLongPress = React.useCallback(\n      (event: Parameters<NonNullable<PressableProps[\"onLongPress\"]>>[0]) => {\n        if (isDisabled) return\n        if (Platform.OS !== \"web\") {\n          onOpenChange(true)\n        }\n        onLongPress?.(event)\n      },\n      [isDisabled, onLongPress, onOpenChange],\n    )\n\n    React.useEffect(() => {\n      if (ref) {\n        if (typeof ref === \"function\") {\n          ref(triggerRef.current)\n        } else {\n          ;(ref as { current: View | null }).current = triggerRef.current\n        }\n      }\n    }, [ref, triggerRef])\n\n    if (asChild && React.isValidElement(children)) {\n      const child = children as React.ReactElement<{\n        onContextMenu?: (event: unknown) => void\n        onLongPress?: (event: unknown) => void\n      }>\n      const childOnContextMenu = child.props.onContextMenu\n      const childOnLongPress = child.props.onLongPress\n      // biome-ignore lint/suspicious/noExplicitAny: Cloning logic\n      return React.cloneElement(child as React.ReactElement<any>, {\n        ref: triggerRef,\n        onContextMenu: composeEventHandlers(childOnContextMenu, handleContextMenu),\n        onLongPress: composeEventHandlers(childOnLongPress, handleLongPress),\n        role: Platform.OS === \"web\" ? \"button\" : undefined,\n        \"aria-expanded\": Platform.OS === \"web\" ? open : undefined,\n        \"aria-haspopup\": Platform.OS === \"web\" ? \"menu\" : undefined,\n        accessibilityRole: \"button\",\n        accessibilityState: {\n          expanded: open,\n          disabled: isDisabled,\n        },\n        disabled: isDisabled,\n        nativeID: triggerId,\n        ...props,\n      })\n    }\n\n    return (\n      <Pressable\n        ref={triggerRef}\n        role={Platform.OS === \"web\" ? \"button\" : undefined}\n        aria-expanded={Platform.OS === \"web\" ? open : undefined}\n        aria-haspopup={Platform.OS === \"web\" ? \"menu\" : undefined}\n        accessibilityRole=\"button\"\n        accessibilityState={{\n          expanded: open,\n          disabled: isDisabled,\n        }}\n        disabled={isDisabled}\n        nativeID={triggerId}\n        // @ts-expect-error - onContextMenu is web-only\n        onContextMenu={Platform.OS === \"web\" ? handleContextMenu : undefined}\n        onLongPress={handleLongPress}\n        delayLongPress={longPressDelay}\n        {...props}\n      >\n        {children}\n      </Pressable>\n    )\n  },\n)\n\nContextMenuTrigger.displayName = \"ContextMenuTrigger\"\n\nexport type ContextMenuContentProps = ViewProps & {\n  side?: Placement\n  sideOffset?: number\n  align?: \"start\" | \"center\" | \"end\"\n  alignOffset?: number\n  avoidCollisions?: boolean\n  dismissable?: boolean\n  onDismiss?: () => void\n  viewportProps?: ScrollViewProps\n}\n\nexport const ContextMenuContent = React.forwardRef<View, ContextMenuContentProps>(\n  (\n    {\n      children,\n      side = \"bottom\",\n      sideOffset = 4,\n      align = \"start\",\n      alignOffset = 0,\n      avoidCollisions = true,\n      dismissable = true,\n      onDismiss,\n      style,\n      viewportProps,\n      ...props\n    },\n    ref,\n  ) => {\n    const {\n      open,\n      onOpenChange,\n      triggerRef,\n      contentRef,\n      modal,\n      activeValue,\n      setActiveValue,\n      triggerId,\n    } = useContextMenu()\n\n    const actualPlacement = align === \"center\" ? side : `${side}-${align}`\n\n    const { position, isPositioned } = usePositioning({\n      anchorRef: triggerRef,\n      contentRef: contentRef,\n      placement: actualPlacement as Placement,\n      offset: sideOffset,\n      alignOffset,\n      flip: avoidCollisions,\n      open,\n    })\n\n    const handleDismiss = React.useCallback(() => {\n      onOpenChange(false)\n      onDismiss?.()\n    }, [onDismiss, onOpenChange])\n\n    const setContentRef = React.useCallback(\n      (node: View | null) => {\n        contentRef.current = node\n        if (typeof ref === \"function\") {\n          ref(node)\n        } else if (ref) {\n          ;(ref as { current: View | null }).current = node\n        }\n      },\n      [contentRef, ref],\n    )\n\n    if (!open) return null\n\n    return (\n      <Portal>\n        <DismissLayer\n          onDismiss={handleDismiss}\n          dismissable={dismissable}\n          scrim={false}\n          scrimStyle={styles.overlay}\n        >\n          <FocusScope trapped={modal} loop={true} style={styles.container}>\n            <View\n              ref={setContentRef}\n              role={Platform.OS === \"web\" ? \"menu\" : undefined}\n              aria-labelledby={Platform.OS === \"web\" ? triggerId : undefined}\n              style={[\n                styles.content,\n                {\n                  position: \"absolute\",\n                  opacity: isPositioned ? 1 : 0,\n                  top: position.top,\n                  left: position.left,\n                },\n                style,\n              ]}\n              {...props}\n            >\n              <ScrollView\n                keyboardShouldPersistTaps=\"handled\"\n                {...viewportProps}\n                contentContainerStyle={[\n                  styles.viewport,\n                  viewportProps?.contentContainerStyle,\n                ]}\n              >\n                <RovingFocusGroup.RovingFocusGroup\n                  orientation=\"vertical\"\n                  value={activeValue}\n                  onValueChange={setActiveValue}\n                  loop\n                >\n                  {children}\n                </RovingFocusGroup.RovingFocusGroup>\n              </ScrollView>\n            </View>\n          </FocusScope>\n        </DismissLayer>\n      </Portal>\n    )\n  },\n)\n\nContextMenuContent.displayName = \"ContextMenuContent\"\n\ntype ContextMenuItemRole = \"menuitem\" | \"menuitemcheckbox\" | \"menuitemradio\"\n\ntype ContextMenuItemBaseProps = Omit<PressableProps, \"children\" | \"role\"> & {\n  children?: React.ReactNode\n  inset?: boolean\n  disabled?: boolean\n  closeOnSelect?: boolean\n  value?: string\n  shortcut?: string\n  indicator?: React.ReactNode\n  role?: ContextMenuItemRole\n  ariaChecked?: boolean\n}\n\nconst ContextMenuItemBase = React.forwardRef<View, ContextMenuItemBaseProps>(\n  (\n    {\n      children,\n      inset,\n      disabled,\n      closeOnSelect = true,\n      value,\n      shortcut,\n      indicator,\n      role,\n      ariaChecked,\n      style,\n      onPress,\n      onFocus,\n      onHoverIn,\n      ...props\n    },\n    ref,\n  ) => {\n    const { onOpenChange, activeValue, setActiveValue } = useContextMenu()\n    const generatedId = React.useId()\n    const itemValue = value ?? generatedId\n    const isDisabled = !!disabled\n    const isActive = activeValue === itemValue\n\n    const variantStyles = styles.useVariants({\n      inset,\n      active: isActive,\n      disabled: isDisabled,\n    })\n\n    const handlePress = React.useCallback(\n      (event: unknown) => {\n        if (isDisabled) return\n        // @ts-expect-error - React Native event type\n        onPress?.(event)\n        if (closeOnSelect) {\n          onOpenChange(false)\n        }\n      },\n      [closeOnSelect, isDisabled, onOpenChange, onPress],\n    )\n\n    const handleHoverIn = React.useCallback(\n      (event: unknown) => {\n        if (isDisabled) return\n        setActiveValue(itemValue)\n        // @ts-expect-error - React Native event type\n        onHoverIn?.(event)\n      },\n      [isDisabled, itemValue, onHoverIn, setActiveValue],\n    )\n\n    const handleFocus = React.useCallback(\n      (event: unknown) => {\n        if (isDisabled) return\n        setActiveValue(itemValue)\n        // @ts-expect-error - React Native event type\n        onFocus?.(event)\n      },\n      [isDisabled, itemValue, onFocus, setActiveValue],\n    )\n\n    const handleKeyDown = React.useCallback(\n      // biome-ignore lint/suspicious/noExplicitAny: Web-only keyboard event type\n      (event: any) => {\n        if (Platform.OS !== \"web\" || isDisabled) return\n        if (event.key === \"Enter\" || event.key === \" \") {\n          event.preventDefault()\n          handlePress(event)\n        }\n      },\n      [handlePress, isDisabled],\n    )\n\n    return (\n      <RovingFocusGroup.RovingFocusItem\n        value={itemValue}\n        disabled={isDisabled}\n        asChild\n      >\n        <Pressable\n          ref={ref}\n          role={\n            Platform.OS === \"web\"\n              ? ((role ?? \"menuitem\") as unknown as \"menuitem\")\n              : undefined\n          }\n          aria-checked={\n            Platform.OS === \"web\" && ariaChecked !== undefined\n              ? ariaChecked\n              : undefined\n          }\n          aria-disabled={Platform.OS === \"web\" ? isDisabled : undefined}\n          accessibilityRole=\"menuitem\"\n          accessibilityState={{\n            disabled: isDisabled,\n            checked: ariaChecked,\n          }}\n          disabled={isDisabled}\n          onPress={handlePress}\n          onHoverIn={handleHoverIn}\n          onFocus={handleFocus}\n          // @ts-expect-error - onKeyDown is web-only\n          onKeyDown={Platform.OS === \"web\" ? handleKeyDown : undefined}\n          style={({ pressed }) =>\n            [\n              styles.item,\n              variantStyles,\n              pressed && !isDisabled && styles.itemPressed,\n              typeof style === \"function\" ? style({ pressed }) : style,\n              // biome-ignore lint/suspicious/noExplicitAny: Complex style array with variants requires type assertion\n            ] as any\n          }\n          {...props}\n        >\n          {indicator ? <View style={styles.itemIndicator}>{indicator}</View> : null}\n          <View style={styles.itemContent}>\n            {typeof children === \"string\" || typeof children === \"number\" ? (\n              <Text style={styles.itemText}>{children}</Text>\n            ) : (\n              children\n            )}\n          </View>\n          {shortcut ? <Text style={styles.shortcut}>{shortcut}</Text> : null}\n        </Pressable>\n      </RovingFocusGroup.RovingFocusItem>\n    )\n  },\n)\n\nContextMenuItemBase.displayName = \"ContextMenuItemBase\"\n\nexport type ContextMenuItemProps = Omit<\n  ContextMenuItemBaseProps,\n  \"role\" | \"ariaChecked\" | \"indicator\"\n> & {\n  indicator?: never\n}\n\nexport const ContextMenuItem = React.forwardRef<View, ContextMenuItemProps>(\n  (props, ref) => {\n    return <ContextMenuItemBase ref={ref} role=\"menuitem\" {...props} />\n  },\n)\n\nContextMenuItem.displayName = \"ContextMenuItem\"\n\nexport type ContextMenuCheckboxItemProps = Omit<\n  ContextMenuItemBaseProps,\n  \"role\" | \"ariaChecked\"\n> & {\n  checked?: boolean\n  defaultChecked?: boolean\n  onCheckedChange?: (checked: boolean) => void\n}\n\nexport const ContextMenuCheckboxItem = React.forwardRef<\n  View,\n  ContextMenuCheckboxItemProps\n>(\n  (\n    {\n      checked: checkedProp,\n      defaultChecked = false,\n      onCheckedChange,\n      onPress,\n      closeOnSelect = true,\n      ...props\n    },\n    ref,\n  ) => {\n    const [uncontrolledChecked, setUncontrolledChecked] =\n      React.useState(defaultChecked)\n    const isControlled = checkedProp !== undefined\n    const checked = isControlled ? checkedProp : uncontrolledChecked\n    const { theme } = useUnistyles()\n\n    const handlePress = React.useCallback(\n      (event: unknown) => {\n        const nextChecked = !checked\n        if (!isControlled) {\n          setUncontrolledChecked(nextChecked)\n        }\n        onCheckedChange?.(nextChecked)\n        // @ts-expect-error - React Native event type\n        onPress?.(event)\n      },\n      [checked, isControlled, onCheckedChange, onPress],\n    )\n\n    return (\n      <ContextMenuItemBase\n        ref={ref}\n        role=\"menuitemcheckbox\"\n        ariaChecked={checked}\n        closeOnSelect={closeOnSelect}\n        indicator={\n          checked ? <Check size={16} color={theme.colors.accentForeground} /> : null\n        }\n        onPress={handlePress}\n        {...props}\n      />\n    )\n  },\n)\n\nContextMenuCheckboxItem.displayName = \"ContextMenuCheckboxItem\"\n\ntype ContextMenuRadioGroupContextValue = {\n  value?: string\n  onValueChange?: (value: string) => void\n}\n\nconst ContextMenuRadioGroupContext =\n  React.createContext<ContextMenuRadioGroupContextValue | null>(null)\n\nexport type ContextMenuRadioGroupProps = ViewProps & {\n  value?: string\n  defaultValue?: string\n  onValueChange?: (value: string) => void\n}\n\nexport const ContextMenuRadioGroup = React.forwardRef<\n  View,\n  ContextMenuRadioGroupProps\n>(({ value: valueProp, defaultValue, onValueChange, ...props }, ref) => {\n  const [value, setValue] = React.useState(valueProp ?? defaultValue)\n  const isControlled = valueProp !== undefined\n  const currentValue = isControlled ? valueProp : value\n\n  const handleValueChange = React.useCallback(\n    (nextValue: string) => {\n      if (!isControlled) {\n        setValue(nextValue)\n      }\n      onValueChange?.(nextValue)\n    },\n    [isControlled, onValueChange],\n  )\n\n  return (\n    <ContextMenuRadioGroupContext.Provider\n      value={{ value: currentValue, onValueChange: handleValueChange }}\n    >\n      <View ref={ref} {...props} />\n    </ContextMenuRadioGroupContext.Provider>\n  )\n})\n\nContextMenuRadioGroup.displayName = \"ContextMenuRadioGroup\"\n\nexport type ContextMenuRadioItemProps = Omit<\n  ContextMenuItemBaseProps,\n  \"role\" | \"ariaChecked\"\n> & {\n  value: string\n}\n\nexport const ContextMenuRadioItem = React.forwardRef<\n  View,\n  ContextMenuRadioItemProps\n>(({ value, onPress, closeOnSelect = true, ...props }, ref) => {\n  const context = React.useContext(ContextMenuRadioGroupContext)\n  if (!context) {\n    throw new Error(\"ContextMenuRadioItem must be used within ContextMenuRadioGroup\")\n  }\n  const { theme } = useUnistyles()\n  const checked = context.value === value\n\n  const handlePress = React.useCallback(\n    (event: unknown) => {\n      context.onValueChange?.(value)\n      // @ts-expect-error - React Native event type\n      onPress?.(event)\n    },\n    [context, onPress, value],\n  )\n\n  return (\n    <ContextMenuItemBase\n      ref={ref}\n      value={value}\n      role=\"menuitemradio\"\n      ariaChecked={checked}\n      closeOnSelect={closeOnSelect}\n      indicator={\n        checked ? (\n          <Circle\n            size={10}\n            fill={theme.colors.accentForeground}\n            color={theme.colors.accentForeground}\n          />\n        ) : null\n      }\n      onPress={handlePress}\n      {...props}\n    />\n  )\n})\n\nContextMenuRadioItem.displayName = \"ContextMenuRadioItem\"\n\nexport type ContextMenuLabelProps = TextProps & {\n  style?: StyleProp<TextStyle>\n}\n\nexport const ContextMenuLabel = React.forwardRef<Text, ContextMenuLabelProps>(\n  ({ style, ...props }, ref) => {\n    return <Text ref={ref} style={[styles.label, style]} {...props} />\n  },\n)\n\nContextMenuLabel.displayName = \"ContextMenuLabel\"\n\nexport type ContextMenuSeparatorProps = ViewProps & {\n  style?: StyleProp<ViewStyle>\n}\n\nexport const ContextMenuSeparator = React.forwardRef<\n  View,\n  ContextMenuSeparatorProps\n>(({ style, ...props }, ref) => {\n  return <View ref={ref} style={[styles.separator, style]} {...props} />\n})\n\nContextMenuSeparator.displayName = \"ContextMenuSeparator\"\n\nexport type ContextMenuGroupProps = ViewProps\n\nexport const ContextMenuGroup = React.forwardRef<View, ContextMenuGroupProps>(\n  ({ style, ...props }, ref) => {\n    return <View ref={ref} style={[styles.group, style]} {...props} />\n  },\n)\n\nContextMenuGroup.displayName = \"ContextMenuGroup\"\n\nconst styles = StyleSheet.create((theme) => ({\n  container: {\n    flex: 1,\n  },\n  overlay: {\n    backgroundColor: \"transparent\",\n  },\n  content: {\n    zIndex: 50,\n    minWidth: 180,\n    borderRadius: theme.radius.md,\n    borderWidth: 1,\n    borderColor: theme.colors.border,\n    backgroundColor: theme.colors.popover,\n    paddingVertical: theme.spacing[2],\n    shadowColor: theme.colors.foreground,\n    shadowOpacity: 0.1,\n    shadowRadius: 6,\n    elevation: 3,\n    maxHeight: 300,\n  },\n  viewport: {\n    paddingHorizontal: theme.spacing[1],\n    gap: theme.spacing[1],\n  },\n  item: {\n    minHeight: theme.spacing[8],\n    paddingHorizontal: theme.spacing[3],\n    paddingVertical: theme.spacing[2],\n    borderRadius: theme.radius.sm,\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: theme.spacing[2],\n    variants: {\n      inset: {\n        true: {\n          paddingLeft: theme.spacing[8],\n        },\n      },\n      active: {\n        true: {\n          backgroundColor: theme.colors.muted,\n        },\n      },\n      disabled: {\n        true: {\n          opacity: 0.5,\n        },\n      },\n    },\n  },\n  itemPressed: {\n    backgroundColor: theme.colors.muted,\n  },\n  itemIndicator: {\n    width: 18,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  itemContent: {\n    flex: 1,\n  },\n  itemText: {\n    fontSize: theme.typography.sizes.sm,\n    lineHeight: theme.typography.lineHeights.sm,\n    color: theme.colors.popoverForeground,\n  },\n  shortcut: {\n    marginLeft: \"auto\",\n    fontSize: theme.typography.sizes.xs,\n    color: theme.colors.mutedForeground,\n  },\n  label: {\n    paddingHorizontal: theme.spacing[3],\n    paddingVertical: theme.spacing[1],\n    fontSize: theme.typography.sizes.xs,\n    textTransform: \"uppercase\",\n    letterSpacing: 0.5,\n    color: theme.colors.mutedForeground,\n  },\n  separator: {\n    height: 1,\n    backgroundColor: theme.colors.border,\n    marginVertical: theme.spacing[1],\n  },\n  group: {\n    gap: theme.spacing[1],\n    paddingVertical: theme.spacing[1],\n  },\n}))\n",
      "type": "registry:ui"
    }
  ]
}
