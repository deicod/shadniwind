{
  "name": "accordion",
  "type": "registry:ui",
  "title": "Accordion",
  "description": "A vertically stacked set of interactive headings that expand or collapse to reveal content.",
  "registryDependencies": [
    "@shadniwind/collapsible",
    "@shadniwind/roving-focus"
  ],
  "files": [
    {
      "path": "components/ui/accordion.tsx",
      "content": "import * as React from \"react\"\nimport {\n  Animated,\n  Platform,\n  Pressable,\n  type PressableProps,\n  Text,\n  View,\n  type ViewProps,\n} from \"react-native\"\nimport { StyleSheet, useUnistyles } from \"react-native-unistyles\"\n// @ts-expect-error - lucide-react-native is a peer dependency\nimport { ChevronDown } from \"lucide-react-native\"\nimport * as RovingFocusGroup from \"../primitives/roving-focus/index\"\n\nexport type AccordionType = \"single\" | \"multiple\"\n\ninterface AccordionContextValue {\n  type: AccordionType\n  openValues: string[]\n  onValueChange: (value: string) => void\n  disabled?: boolean\n}\n\nconst AccordionContext = React.createContext<AccordionContextValue | undefined>(\n  undefined,\n)\n\nfunction useAccordion() {\n  const context = React.useContext(AccordionContext)\n  if (!context) {\n    throw new Error(\"Accordion components must be used within Accordion\")\n  }\n  return context\n}\n\ninterface AccordionItemContextValue {\n  value: string\n  open: boolean\n  onToggle: () => void\n}\n\nconst AccordionItemContext = React.createContext<\n  AccordionItemContextValue | undefined\n>(undefined)\n\nfunction useAccordionItem() {\n  const context = React.useContext(AccordionItemContext)\n  if (!context) {\n    throw new Error(\n      \"AccordionItem components must be used within AccordionItem\",\n    )\n  }\n  return context\n}\n\nexport interface AccordionProps extends ViewProps {\n  type?: AccordionType\n  value?: string | string[]\n  defaultValue?: string | string[]\n  onValueChange?: (value: string | string[]) => void\n  disabled?: boolean\n}\n\nexport const Accordion = React.forwardRef<View, AccordionProps>(\n  (\n    {\n      type = \"single\",\n      value: valueProp,\n      defaultValue,\n      onValueChange,\n      disabled = false,\n      children,\n      style,\n      ...props\n    },\n    ref,\n  ) => {\n    const defaultOpenValues = React.useMemo(() => {\n      if (defaultValue === undefined) return []\n      if (Array.isArray(defaultValue)) return defaultValue\n      return [defaultValue]\n    }, [defaultValue])\n\n    const [openValues, setOpenValues] = React.useState<string[]>(\n      valueProp !== undefined\n        ? Array.isArray(valueProp)\n          ? valueProp\n          : [valueProp]\n        : defaultOpenValues,\n    )\n\n    const isControlled = valueProp !== undefined\n    const currentOpenValues = isControlled\n      ? Array.isArray(valueProp)\n        ? valueProp\n        : [valueProp]\n      : openValues\n\n    // Track focused item for roving focus (separate from open state)\n    const [focusedValue, setFocusedValue] = React.useState<string | undefined>(\n      isControlled\n        ? Array.isArray(currentOpenValues) && currentOpenValues.length > 0\n          ? currentOpenValues[0]\n          : undefined\n        : Array.isArray(defaultOpenValues) && defaultOpenValues.length > 0\n          ? defaultOpenValues[0]\n          : undefined,\n    )\n\n    // Sync focused value when open values change (for single mode)\n    React.useEffect(() => {\n      if (type === \"single\" && currentOpenValues.length > 0) {\n        setFocusedValue(currentOpenValues[0])\n      }\n    }, [currentOpenValues, type])\n\n    const handleValueChange = React.useCallback(\n      (newValue: string) => {\n        if (disabled) return\n\n        if (type === \"single\") {\n          const isOpen = currentOpenValues.includes(newValue)\n          const newValues = isOpen ? [] : [newValue]\n          if (!isControlled) {\n            setOpenValues(newValues)\n          }\n          onValueChange?.(newValues[0] ?? \"\")\n        } else {\n          const isOpen = currentOpenValues.includes(newValue)\n          const newValues = isOpen\n            ? currentOpenValues.filter((v) => v !== newValue)\n            : [...currentOpenValues, newValue]\n          if (!isControlled) {\n            setOpenValues(newValues)\n          }\n          onValueChange?.(newValues)\n        }\n      },\n      [type, currentOpenValues, disabled, isControlled, onValueChange],\n    )\n\n    return (\n      <AccordionContext.Provider\n        value={{\n          type,\n          openValues: currentOpenValues,\n          onValueChange: handleValueChange,\n          disabled,\n        }}\n      >\n        <RovingFocusGroup.RovingFocusGroup\n          orientation=\"vertical\"\n          value={focusedValue ?? \"\"}\n          onValueChange={setFocusedValue}\n          loop\n          {...props}\n          ref={ref}\n          style={[styles.accordion, style]}\n        >\n          {children}\n        </RovingFocusGroup.RovingFocusGroup>\n      </AccordionContext.Provider>\n    )\n  },\n)\n\nAccordion.displayName = \"Accordion\"\n\nexport interface AccordionItemProps extends ViewProps {\n  value: string\n  disabled?: boolean\n}\n\nexport const AccordionItem = React.forwardRef<View, AccordionItemProps>(\n  ({ value, disabled = false, children, style, ...props }, ref) => {\n    const context = React.useContext(AccordionContext)\n    if (!context) {\n      throw new Error(\"AccordionItem must be used within Accordion\")\n    }\n\n    const open = context.openValues.includes(value)\n\n    const handleToggle = React.useCallback(() => {\n      if (disabled || context.disabled) return\n      context.onValueChange(value)\n    }, [value, disabled, context])\n\n    return (\n      <AccordionItemContext.Provider\n        value={{ value, open, onToggle: handleToggle }}\n      >\n        <View\n          ref={ref}\n          style={[styles.item, disabled && styles.itemDisabled, style]}\n          {...props}\n        >\n          {children}\n        </View>\n      </AccordionItemContext.Provider>\n    )\n  },\n)\n\nAccordionItem.displayName = \"AccordionItem\"\n\nexport interface AccordionTriggerProps extends PressableProps {\n  showChevron?: boolean\n}\n\nexport const AccordionTrigger = React.forwardRef<\n  React.ComponentRef<typeof Pressable>,\n  AccordionTriggerProps\n>(({ showChevron = true, children, style, ...props }, ref) => {\n  const itemContext = useAccordionItem()\n  const accordionContext = useAccordion()\n  const isDisabled = props.disabled ?? accordionContext.disabled\n  const { theme } = useUnistyles()\n\n  const handlePress = () => {\n    if (!isDisabled) {\n      itemContext.onToggle()\n    }\n  }\n\n  const content = (\n    <Pressable\n      ref={ref}\n      role={Platform.OS === \"web\" ? \"button\" : undefined}\n      aria-expanded={Platform.OS === \"web\" ? itemContext.open : undefined}\n      aria-disabled={Platform.OS === \"web\" ? isDisabled : undefined}\n      accessible={true}\n      accessibilityRole=\"button\"\n      accessibilityState={{\n        expanded: itemContext.open,\n        disabled: isDisabled,\n      }}\n      onPress={handlePress}\n      disabled={isDisabled}\n      style={({ pressed }) =>\n        [\n          styles.trigger,\n          itemContext.open && styles.triggerOpen,\n          isDisabled && styles.triggerDisabled,\n          pressed && !isDisabled && styles.triggerPressed,\n          typeof style === \"function\" ? style({ pressed }) : style,\n          // biome-ignore lint/suspicious/noExplicitAny: Style array with conditional items requires type assertion\n        ] as any\n      }\n      {...props}\n    >\n      <View style={styles.triggerContent}>\n        {/* biome-ignore lint/complexity/noUselessFragments: Required for TypeScript type inference workaround */}\n        <>\n          {typeof children === \"string\" ? (\n            <Text\n              style={[\n                styles.triggerText,\n                itemContext.open && styles.triggerTextOpen,\n                isDisabled && styles.triggerTextDisabled,\n              ]}\n            >\n              {children}\n            </Text>\n          ) : (\n            children\n          )}\n        </>\n      </View>\n      {showChevron && (\n        <View style={[styles.chevron, itemContext.open && styles.chevronOpen]}>\n          <ChevronDown\n            size={20}\n            color={\n              isDisabled\n                ? theme.colors.mutedForeground\n                : theme.colors.foreground\n            }\n          />\n        </View>\n      )}\n    </Pressable>\n  )\n\n  return (\n    <RovingFocusGroup.RovingFocusItem\n      value={itemContext.value}\n      disabled={isDisabled}\n      asChild\n    >\n      {content}\n    </RovingFocusGroup.RovingFocusItem>\n  )\n})\n\nAccordionTrigger.displayName = \"AccordionTrigger\"\n\nexport interface AccordionContentProps extends ViewProps {\n  animated?: boolean\n}\n\nexport const AccordionContent = React.forwardRef<View, AccordionContentProps>(\n  ({ animated = true, children, style, ...props }, ref) => {\n    const itemContext = useAccordionItem()\n\n    const animatedHeight = React.useRef(\n      new Animated.Value(itemContext.open ? 1 : 0),\n    ).current\n    const [contentHeight, setContentHeight] = React.useState<number>(0)\n\n    React.useEffect(() => {\n      Animated.timing(animatedHeight, {\n        toValue: itemContext.open ? 1 : 0,\n        duration: 200,\n        useNativeDriver: false,\n      }).start()\n    }, [itemContext.open, animatedHeight])\n\n    const handleLayout = React.useCallback(\n      // biome-ignore lint/suspicious/noExplicitAny: Layout event type\n      (event: any) => {\n        const { height } = event.nativeEvent.layout\n        if (height > 0 && height !== contentHeight) {\n          setContentHeight(height)\n        }\n      },\n      [contentHeight],\n    )\n\n    const heightInterpolation = animatedHeight.interpolate({\n      inputRange: [0, 1],\n      outputRange: [0, contentHeight],\n    })\n\n    const opacityInterpolation = animatedHeight.interpolate({\n      inputRange: [0, 0.5, 1],\n      outputRange: [0, 0.5, 1],\n    })\n\n    if (contentHeight === 0) {\n      return (\n        <View\n          onLayout={handleLayout}\n          style={[styles.contentMeasuring, style]}\n          {...props}\n        >\n          <View>{children}</View>\n        </View>\n      )\n    }\n\n    if (!animated) {\n      return itemContext.open ? (\n        <View ref={ref} style={[styles.content, style]} {...props}>\n          <View onLayout={handleLayout}>{children}</View>\n        </View>\n      ) : null\n    }\n\n    return (\n      <Animated.View\n        ref={ref}\n        role={Platform.OS === \"web\" ? \"region\" : undefined}\n        style={[\n          styles.animatedContent,\n          {\n            height: heightInterpolation,\n            opacity: opacityInterpolation,\n          },\n          style,\n        ]}\n        {...props}\n      >\n        <View onLayout={handleLayout}>{children}</View>\n      </Animated.View>\n    )\n  },\n)\n\nAccordionContent.displayName = \"AccordionContent\"\n\nconst styles = StyleSheet.create((theme) => ({\n  accordion: {\n    gap: 0,\n  },\n  item: {\n    borderBottomWidth: 1,\n    borderBottomColor: theme.colors.border,\n  },\n  itemDisabled: {\n    opacity: 0.5,\n  },\n  trigger: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    padding: 16,\n    minHeight: 48,\n    backgroundColor: theme.colors.background,\n  },\n  triggerOpen: {},\n  triggerDisabled: {\n    opacity: 0.5,\n  },\n  triggerPressed: {\n    opacity: 0.8,\n  },\n  triggerContent: {\n    flex: 1,\n  },\n  triggerText: {\n    fontSize: theme.typography.sizes.md,\n    fontWeight: theme.typography.weights.medium,\n    color: theme.colors.foreground,\n  },\n  triggerTextOpen: {},\n  triggerTextDisabled: {\n    color: theme.colors.mutedForeground,\n  },\n  chevron: {\n    marginLeft: 12,\n    transform: [{ rotate: \"0deg\" }],\n  },\n  chevronOpen: {\n    transform: [{ rotate: \"180deg\" }],\n  },\n  content: {\n    overflow: \"hidden\",\n  },\n  contentMeasuring: {\n    position: \"absolute\",\n    opacity: 0,\n    zIndex: -1,\n  },\n  animatedContent: {\n    overflow: \"hidden\",\n  },\n}))\n",
      "type": "registry:ui"
    }
  ]
}
