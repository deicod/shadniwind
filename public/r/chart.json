{
  "name": "chart",
  "type": "registry:ui",
  "title": "Chart",
  "description": "SVG-based chart component for simple line, area, and bar charts.",
  "dependencies": [
    "react-native-svg"
  ],
  "registryDependencies": [
    "@shadniwind/tokens"
  ],
  "files": [
    {
      "path": "components/ui/chart.tsx",
      "content": "import * as React from \"react\"\nimport {\n  type LayoutChangeEvent,\n  type StyleProp,\n  Text,\n  View,\n  type ViewProps,\n  type ViewStyle,\n  type TextStyle,\n} from \"react-native\"\nimport { StyleSheet, useUnistyles } from \"react-native-unistyles\"\nimport { Circle, Line, Path, Rect, Svg } from \"react-native-svg\"\n\nexport type ChartType = \"line\" | \"bar\" | \"area\"\n\nexport type ChartDatum = Record<string, number | string | null | undefined>\n\nexport type ChartSeries = {\n  id: string\n  dataKey: string\n  label?: string\n  color?: string\n  type?: ChartType\n  strokeWidth?: number\n  fillOpacity?: number\n  showDots?: boolean\n  dotSize?: number\n}\n\nexport type ChartProps = ViewProps & {\n  data: ChartDatum[]\n  series: ChartSeries[]\n  width?: number\n  height?: number\n  padding?: number\n  minValue?: number\n  maxValue?: number\n  showGrid?: boolean\n  gridLineCount?: number\n}\n\nexport type ChartLegendProps = {\n  series: ChartSeries[]\n  style?: StyleProp<ViewStyle>\n  labelStyle?: StyleProp<TextStyle>\n  indicatorStyle?: StyleProp<ViewStyle>\n}\n\ntype ChartPoint = {\n  x: number\n  y: number\n  value: number\n}\n\nconst DEFAULT_HEIGHT = 180\nconst DEFAULT_GRID_LINES = 4\n\nfunction toNumber(value: unknown) {\n  if (typeof value === \"number\" && !Number.isNaN(value)) return value\n  if (typeof value === \"string\" && value.trim().length > 0) {\n    const parsed = Number(value)\n    if (!Number.isNaN(parsed)) return parsed\n  }\n  return null\n}\n\nfunction buildLinePath(points: ChartPoint[]) {\n  if (!points.length) return \"\"\n  return points\n    .map((point, index) => {\n      const prefix = index === 0 ? \"M\" : \"L\"\n      return `${prefix}${point.x} ${point.y}`\n    })\n    .join(\" \")\n}\n\nfunction buildAreaPath(points: ChartPoint[], baselineY: number) {\n  if (!points.length) return \"\"\n  const line = buildLinePath(points)\n  const lastPoint = points[points.length - 1]\n  const firstPoint = points[0]\n  return `${line} L ${lastPoint.x} ${baselineY} L ${firstPoint.x} ${baselineY} Z`\n}\n\nfunction clamp(value: number, min: number, max: number) {\n  return Math.min(Math.max(value, min), max)\n}\n\n/**\n * Simple SVG-based chart component.\n *\n * Supports line, area, and bar series. Data is scaled by min/max values and\n * rendered with index-based X positions.\n *\n * Limitations:\n * - No axes, tooltips, or gesture interactions.\n * - Values are treated as numeric; non-numeric entries are clamped to the\n *   min value.\n * - Intended for small datasets and dashboard-style visuals.\n *\n * Requires `react-native-svg` to be installed.\n */\nexport const Chart = React.forwardRef<View, ChartProps>(\n  (\n    {\n      data,\n      series,\n      width,\n      height = DEFAULT_HEIGHT,\n      padding,\n      minValue,\n      maxValue,\n      showGrid = false,\n      gridLineCount = DEFAULT_GRID_LINES,\n      style,\n      onLayout,\n      ...props\n    },\n    ref,\n  ) => {\n    const { theme } = useUnistyles()\n    const [measuredWidth, setMeasuredWidth] = React.useState(0)\n\n    const handleLayout = React.useCallback(\n      (event: LayoutChangeEvent) => {\n        if (width === undefined) {\n          setMeasuredWidth(event.nativeEvent.layout.width)\n        }\n        onLayout?.(event)\n      },\n      [onLayout, width],\n    )\n\n    const resolvedWidth = width ?? measuredWidth\n    const resolvedPadding = padding ?? theme.spacing[4]\n    const innerWidth = Math.max(0, resolvedWidth - resolvedPadding * 2)\n    const innerHeight = Math.max(0, height - resolvedPadding * 2)\n\n    const palette = React.useMemo(\n      () => [\n        theme.colors.primary,\n        theme.colors.secondary,\n        theme.colors.accent,\n        theme.colors.destructive,\n        theme.colors.ring,\n        theme.colors.mutedForeground,\n      ],\n      [theme],\n    )\n\n    const resolvedSeries = React.useMemo(\n      () =>\n        series.map((item, index) => ({\n          ...item,\n          type: item.type ?? \"line\",\n          color: item.color ?? palette[index % palette.length],\n          strokeWidth: item.strokeWidth ?? 2,\n          fillOpacity: item.fillOpacity ?? 0.2,\n          dotSize: item.dotSize ?? 4,\n        })),\n      [palette, series],\n    )\n\n    const numericValues = React.useMemo(() => {\n      const values: number[] = []\n      for (const item of resolvedSeries) {\n        for (const datum of data) {\n          const value = toNumber(datum[item.dataKey])\n          if (value !== null) values.push(value)\n        }\n      }\n      return values\n    }, [data, resolvedSeries])\n\n    const computedMin =\n      minValue ?? (numericValues.length ? Math.min(...numericValues) : 0)\n    const computedMax =\n      maxValue ??\n      (numericValues.length ? Math.max(...numericValues) : computedMin + 1)\n    const resolvedMin = computedMin\n    const resolvedMax = Math.max(computedMax, resolvedMin)\n    const range = resolvedMax - resolvedMin || 1\n\n    const lineStep = data.length > 1 ? innerWidth / (data.length - 1) : 0\n    const baselineY = resolvedPadding + innerHeight\n\n    const barSeries = resolvedSeries.filter((item) => item.type === \"bar\")\n    const barGroupWidth = data.length ? innerWidth / data.length : 0\n    const barGap = Math.min(barGroupWidth * 0.2, resolvedPadding)\n    const barWidth =\n      barSeries.length > 0\n        ? Math.max(0, (barGroupWidth - barGap) / barSeries.length)\n        : 0\n    const barRadius = theme.radius.sm\n\n    const gridLines = React.useMemo(() => {\n      if (!showGrid || gridLineCount <= 0) return []\n      return Array.from({ length: gridLineCount + 1 }, (_, index) => {\n        const y =\n          resolvedPadding + (innerHeight / gridLineCount) * index\n        return { key: `grid-${Math.round(y * 1000)}`, y }\n      })\n    }, [gridLineCount, innerHeight, resolvedPadding, showGrid])\n\n    const containerStyle: StyleProp<ViewStyle> = [\n      styles.container,\n      { height, width: width ?? undefined },\n      style,\n    ]\n\n    return (\n      <View\n        ref={ref}\n        style={containerStyle}\n        onLayout={handleLayout}\n        accessibilityRole={props.accessibilityRole ?? \"image\"}\n        {...props}\n      >\n        {resolvedWidth > 0 && innerWidth > 0 && innerHeight > 0 ? (\n          <Svg width={resolvedWidth} height={height}>\n            {gridLines.map((line) => (\n              <Line\n                key={line.key}\n                x1={resolvedPadding}\n                x2={resolvedPadding + innerWidth}\n                y1={line.y}\n                y2={line.y}\n                stroke={theme.colors.border}\n                strokeWidth={1}\n              />\n            ))}\n\n            {barSeries.map((item, seriesIndex) => {\n              return data.map((datum, datumIndex) => {\n                const rawValue = toNumber(datum[item.dataKey]) ?? resolvedMin\n                const normalized = clamp((rawValue - resolvedMin) / range, 0, 1)\n                const barHeight = innerHeight * normalized\n                const x =\n                  resolvedPadding +\n                  datumIndex * barGroupWidth +\n                  barGap / 2 +\n                  seriesIndex * barWidth\n                const y = baselineY - barHeight\n\n                return (\n                  <Rect\n                    key={`${item.id}-bar-${datumIndex}`}\n                    x={x}\n                    y={y}\n                    width={barWidth}\n                    height={barHeight}\n                    rx={barRadius}\n                    ry={barRadius}\n                    fill={item.color}\n                  />\n                )\n              })\n            })}\n\n            {resolvedSeries.map((item) => {\n              if (item.type === \"bar\") return null\n              const points: ChartPoint[] = data.map((datum, index) => {\n                const rawValue = toNumber(datum[item.dataKey]) ?? resolvedMin\n                const normalized = clamp((rawValue - resolvedMin) / range, 0, 1)\n                const x =\n                  resolvedPadding +\n                  (data.length > 1 ? lineStep * index : innerWidth / 2)\n                const y = baselineY - innerHeight * normalized\n                return { x, y, value: rawValue }\n              })\n\n              const linePath = buildLinePath(points)\n              const areaPath = buildAreaPath(points, baselineY)\n\n              return (\n                <React.Fragment key={item.id}>\n                  {item.type === \"area\" ? (\n                    <>\n                      <Path\n                        d={areaPath}\n                        fill={item.color}\n                        fillOpacity={item.fillOpacity}\n                        stroke=\"none\"\n                      />\n                      <Path\n                        d={linePath}\n                        stroke={item.color}\n                        strokeWidth={item.strokeWidth}\n                        fill=\"none\"\n                      />\n                    </>\n                  ) : (\n                    <Path\n                      d={linePath}\n                      stroke={item.color}\n                      strokeWidth={item.strokeWidth}\n                      fill=\"none\"\n                    />\n                  )}\n\n                  {item.showDots\n                    ? points.map((point, index) => (\n                        <Circle\n                          key={`${item.id}-dot-${index}`}\n                          cx={point.x}\n                          cy={point.y}\n                          r={item.dotSize ?? 4}\n                          fill={item.color}\n                        />\n                      ))\n                    : null}\n                </React.Fragment>\n              )\n            })}\n          </Svg>\n        ) : null}\n      </View>\n    )\n  },\n)\n\nChart.displayName = \"Chart\"\n\nexport function ChartLegend({\n  series,\n  style,\n  labelStyle,\n  indicatorStyle,\n}: ChartLegendProps) {\n  const { theme } = useUnistyles()\n  const palette = React.useMemo(\n    () => [\n      theme.colors.primary,\n      theme.colors.secondary,\n      theme.colors.accent,\n      theme.colors.destructive,\n      theme.colors.ring,\n      theme.colors.mutedForeground,\n    ],\n    [theme],\n  )\n\n  return (\n    <View style={[styles.legend, style]}>\n      {series.map((item, index) => {\n        const color = item.color ?? palette[index % palette.length]\n        return (\n          <View key={item.id} style={styles.legendItem}>\n            <View\n              style={[\n                styles.legendSwatch,\n                { backgroundColor: color },\n                indicatorStyle,\n              ]}\n            />\n            <Text style={[styles.legendLabel, labelStyle]}>\n              {item.label ?? item.id}\n            </Text>\n          </View>\n        )\n      })}\n    </View>\n  )\n}\n\nconst styles = StyleSheet.create((theme) => ({\n  container: {\n    width: \"100%\",\n    borderWidth: 1,\n    borderColor: theme.colors.border,\n    borderRadius: theme.radius.md,\n    backgroundColor: theme.colors.card,\n    overflow: \"hidden\",\n  },\n  legend: {\n    flexDirection: \"row\",\n    flexWrap: \"wrap\",\n    alignItems: \"center\",\n    gap: theme.spacing[2],\n  },\n  legendItem: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: theme.spacing[1],\n  },\n  legendSwatch: {\n    width: 12,\n    height: 12,\n    borderRadius: 6,\n  },\n  legendLabel: {\n    fontSize: theme.typography.sizes.sm,\n    color: theme.colors.mutedForeground,\n  },\n}))\n",
      "type": "registry:ui"
    }
  ]
}
