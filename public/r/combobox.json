{
  "name": "combobox",
  "type": "registry:ui",
  "title": "Combobox",
  "description": "Provides a searchable list of options in an input-driven overlay.",
  "registryDependencies": [
    "tokens",
    "portal",
    "positioning",
    "focus",
    "overlay",
    "roving-focus"
  ],
  "files": [
    {
      "path": "components/ui/combobox.tsx",
      "content": "import * as React from \"react\"\nimport {\n  Platform,\n  Pressable,\n  type PressableProps,\n  ScrollView,\n  type ScrollViewProps,\n  type StyleProp,\n  Text,\n  type TextProps,\n  TextInput,\n  type TextInputProps,\n  type TextStyle,\n  View,\n  type ViewProps,\n  type ViewStyle,\n} from \"react-native\"\nimport { StyleSheet, useUnistyles } from \"react-native-unistyles\"\n// @ts-expect-error - lucide-react-native is a peer dependency\nimport { Check } from \"lucide-react-native\"\nimport { FocusScope } from \"../primitives/focus/index.js\"\nimport { DismissLayer } from \"../primitives/overlay/index.js\"\nimport { Portal } from \"../primitives/portal/index.js\"\nimport {\n  type Placement,\n  usePositioning,\n} from \"../primitives/positioning/index.js\"\nimport * as RovingFocusGroup from \"../primitives/roving-focus/index.js\"\n\ntype ComboboxItemData = {\n  value: string\n  label: string\n  disabled?: boolean\n  order: number\n}\n\ntype ComboboxFilter = (item: ComboboxItemData, query: string) => boolean\n\ntype ComboboxContextValue = {\n  open: boolean\n  onOpenChange: (open: boolean) => void\n  value?: string\n  onValueChange: (value: string) => void\n  inputValue: string\n  setInputValue: (value: string) => void\n  disabled?: boolean\n  modal: boolean\n  anchorRef: React.RefObject<View | null>\n  contentRef: React.RefObject<View | null>\n  registerItem: (value: string, label: string, disabled?: boolean) => () => void\n  items: ComboboxItemData[]\n  filteredItems: ComboboxItemData[]\n  selectedLabel?: string\n  activeValue?: string\n  setActiveValue: (value?: string) => void\n  listId: string\n  inputId: string\n  shouldFilter: boolean\n  filterItem: ComboboxFilter\n  getItemId: (value: string) => string\n}\n\nconst ComboboxContext = React.createContext<ComboboxContextValue | undefined>(\n  undefined,\n)\n\nfunction useCombobox() {\n  const context = React.useContext(ComboboxContext)\n  if (!context) {\n    throw new Error(\"Combobox components must be used within Combobox\")\n  }\n  return context\n}\n\nexport type ComboboxProps = {\n  children: React.ReactNode\n  value?: string\n  defaultValue?: string\n  onValueChange?: (value: string) => void\n  inputValue?: string\n  defaultInputValue?: string\n  onInputValueChange?: (value: string) => void\n  open?: boolean\n  defaultOpen?: boolean\n  onOpenChange?: (open: boolean) => void\n  disabled?: boolean\n  modal?: boolean\n  shouldFilter?: boolean\n  filter?: ComboboxFilter\n}\n\n/**\n * Combobox component.\n *\n * Platform notes:\n * - Web: uses combobox/listbox roles with keyboard navigation; Enter selection\n *   is ignored while IME composition is active.\n * - Native: list renders in a portal overlay anchored to the input.\n */\nexport function Combobox({\n  children,\n  value: valueProp,\n  defaultValue,\n  onValueChange,\n  inputValue: inputValueProp,\n  defaultInputValue,\n  onInputValueChange,\n  open: openProp,\n  defaultOpen = false,\n  onOpenChange,\n  disabled = false,\n  modal = false,\n  shouldFilter = true,\n  filter,\n}: ComboboxProps) {\n  const [open, setOpen] = React.useState(defaultOpen)\n  const [value, setValue] = React.useState<string | undefined>(\n    valueProp ?? defaultValue,\n  )\n  const [inputValue, setInputValue] = React.useState(\n    defaultInputValue ?? \"\",\n  )\n  const [activeValue, setActiveValue] = React.useState<string | undefined>(\n    valueProp ?? defaultValue,\n  )\n  const [itemsVersion, setItemsVersion] = React.useState(0)\n  const anchorRef = React.useRef<View>(null)\n  const contentRef = React.useRef<View>(null)\n  const itemsRef = React.useRef<Map<string, ComboboxItemData>>(new Map())\n  const labelMapRef = React.useRef<Map<string, string>>(new Map())\n  const orderRef = React.useRef(0)\n  const orderMapRef = React.useRef<Map<string, number>>(new Map())\n  const listId = React.useId()\n  const inputId = React.useId()\n\n  const isControlledValue = valueProp !== undefined\n  const currentValue = isControlledValue ? valueProp : value\n  const isControlledInput = inputValueProp !== undefined\n  const currentInputValue = isControlledInput ? inputValueProp ?? \"\" : inputValue\n  const isControlledOpen = openProp !== undefined\n  const currentOpen = isControlledOpen ? openProp : open\n\n  const items = React.useMemo(() => {\n    const currentVersion = itemsVersion\n    void currentVersion\n    return Array.from(itemsRef.current.values()).sort(\n      (a, b) => a.order - b.order,\n    )\n  }, [itemsVersion])\n\n  const filterItem = React.useCallback<ComboboxFilter>(\n    (item, query) => {\n      if (!query) return true\n      return item.label.toLowerCase().includes(query.toLowerCase())\n    },\n    [],\n  )\n\n  const activeFilter = filter ?? filterItem\n\n  const filteredItems = React.useMemo(() => {\n    if (!shouldFilter) return items\n    const query = currentInputValue.trim()\n    if (!query) return items\n    return items.filter((item) => activeFilter(item, query))\n  }, [activeFilter, currentInputValue, items, shouldFilter])\n\n  const selectedLabel = React.useMemo(() => {\n    if (currentValue === undefined) return undefined\n    return (\n      items.find((item) => item.value === currentValue)?.label ??\n      labelMapRef.current.get(currentValue)\n    )\n  }, [currentValue, items])\n\n  const registerItem = React.useCallback(\n    (itemValue: string, label: string, itemDisabled?: boolean) => {\n      const existingOrder = orderMapRef.current.get(itemValue)\n      const order = existingOrder ?? orderRef.current++\n      orderMapRef.current.set(itemValue, order)\n      labelMapRef.current.set(itemValue, label)\n      itemsRef.current.set(itemValue, {\n        value: itemValue,\n        label,\n        disabled: itemDisabled,\n        order,\n      })\n      setItemsVersion((prev) => prev + 1)\n\n      return () => {\n        itemsRef.current.delete(itemValue)\n        setItemsVersion((prev) => prev + 1)\n      }\n    },\n    [],\n  )\n\n  const handleOpenChange = React.useCallback(\n    (nextOpen: boolean) => {\n      if (disabled && nextOpen) return\n      if (!isControlledOpen) {\n        setOpen(nextOpen)\n      }\n      onOpenChange?.(nextOpen)\n    },\n    [disabled, isControlledOpen, onOpenChange],\n  )\n\n  const handleValueChange = React.useCallback(\n    (nextValue: string) => {\n      if (disabled) return\n      if (!isControlledValue) {\n        setValue(nextValue)\n      }\n      onValueChange?.(nextValue)\n      setActiveValue(nextValue)\n\n      const nextLabel =\n        itemsRef.current.get(nextValue)?.label ??\n        labelMapRef.current.get(nextValue)\n      if (nextLabel !== undefined) {\n        if (!isControlledInput) {\n          setInputValue(nextLabel)\n        }\n        onInputValueChange?.(nextLabel)\n      }\n    },\n    [\n      disabled,\n      isControlledInput,\n      isControlledValue,\n      onInputValueChange,\n      onValueChange,\n    ],\n  )\n\n  const handleInputValueChange = React.useCallback(\n    (nextValue: string) => {\n      if (disabled) return\n      if (!isControlledInput) {\n        setInputValue(nextValue)\n      }\n      onInputValueChange?.(nextValue)\n      if (!currentOpen) {\n        handleOpenChange(true)\n      }\n    },\n    [\n      disabled,\n      handleOpenChange,\n      isControlledInput,\n      currentOpen,\n      onInputValueChange,\n    ],\n  )\n\n  const getItemId = React.useCallback(\n    (itemValue: string) => `${listId}-item-${encodeURIComponent(itemValue)}`,\n    [listId],\n  )\n\n  React.useEffect(() => {\n    if (isControlledInput) return\n    if (selectedLabel === undefined) return\n    setInputValue(selectedLabel)\n  }, [isControlledInput, selectedLabel])\n\n  React.useEffect(() => {\n    if (!currentOpen) return\n    if (filteredItems.length === 0) {\n      setActiveValue(undefined)\n      return\n    }\n    const selectedItem = filteredItems.find(\n      (item) => item.value === currentValue && !item.disabled,\n    )\n    const firstEnabled =\n      selectedItem ?? filteredItems.find((item) => !item.disabled)\n    if (firstEnabled) {\n      setActiveValue(firstEnabled.value)\n    }\n  }, [currentOpen, currentValue, filteredItems])\n\n  return (\n    <ComboboxContext.Provider\n      value={{\n        open: !!currentOpen,\n        onOpenChange: handleOpenChange,\n        value: currentValue,\n        onValueChange: handleValueChange,\n        inputValue: currentInputValue,\n        setInputValue: handleInputValueChange,\n        disabled,\n        modal,\n        anchorRef,\n        contentRef,\n        registerItem,\n        items,\n        filteredItems,\n        selectedLabel,\n        activeValue,\n        setActiveValue,\n        listId,\n        inputId,\n        shouldFilter,\n        filterItem: activeFilter,\n        getItemId,\n      }}\n    >\n      {children}\n    </ComboboxContext.Provider>\n  )\n}\n\nexport type ComboboxInputProps = Omit<\n  TextInputProps,\n  \"value\" | \"defaultValue\" | \"onChangeText\"\n> & {\n  onChangeText?: TextInputProps[\"onChangeText\"]\n  onKeyDown?: (event: unknown) => void\n  onCompositionStart?: (event: unknown) => void\n  onCompositionEnd?: (event: unknown) => void\n  openOnFocus?: boolean\n  style?: StyleProp<TextStyle>\n}\n\nexport const ComboboxInput = React.forwardRef<TextInput, ComboboxInputProps>(\n  (\n    {\n      onChangeText,\n      onFocus,\n      onBlur,\n      onKeyDown,\n      onCompositionStart,\n      onCompositionEnd,\n      openOnFocus = true,\n      style,\n      editable,\n      placeholderTextColor,\n      ...props\n    },\n    ref,\n  ) => {\n    const {\n      open,\n      onOpenChange,\n      inputValue,\n      setInputValue,\n      onValueChange,\n      disabled,\n      anchorRef,\n      listId,\n      inputId,\n      activeValue,\n      setActiveValue,\n      filteredItems,\n      getItemId,\n    } = useCombobox()\n    const { theme } = useUnistyles()\n    const [isFocused, setIsFocused] = React.useState(false)\n    const isDisabled = disabled || editable === false\n    const isComposingRef = React.useRef(false)\n\n    styles.useVariants({\n      focused: isFocused,\n      disabled: isDisabled,\n    })\n\n    const setInputRef = React.useCallback(\n      (node: TextInput | null) => {\n        anchorRef.current = node as unknown as View | null\n        if (typeof ref === \"function\") {\n          ref(node)\n        } else if (ref) {\n          ;(ref as { current: TextInput | null }).current = node\n        }\n      },\n      [anchorRef, ref],\n    )\n\n    const getNextActiveValue = React.useCallback(\n      (direction: \"next\" | \"prev\") => {\n        const enabledItems = filteredItems.filter((item) => !item.disabled)\n        if (enabledItems.length === 0) return undefined\n        const currentIndex = enabledItems.findIndex(\n          (item) => item.value === activeValue,\n        )\n        if (currentIndex === -1) {\n          return direction === \"next\"\n            ? enabledItems[0]?.value\n            : enabledItems[enabledItems.length - 1]?.value\n        }\n        const nextIndex =\n          direction === \"next\"\n            ? Math.min(currentIndex + 1, enabledItems.length - 1)\n            : Math.max(currentIndex - 1, 0)\n        return enabledItems[nextIndex]?.value\n      },\n      [activeValue, filteredItems],\n    )\n\n    const handleChangeText = React.useCallback(\n      (text: string) => {\n        setInputValue(text)\n        onChangeText?.(text)\n      },\n      [onChangeText, setInputValue],\n    )\n\n    const handleFocus = React.useCallback(\n      (event: unknown) => {\n        setIsFocused(true)\n        if (!isDisabled && openOnFocus && !open) {\n          onOpenChange(true)\n        }\n        // @ts-expect-error - React Native event type\n        onFocus?.(event)\n      },\n      [isDisabled, onFocus, onOpenChange, open, openOnFocus],\n    )\n\n    const handleBlur = React.useCallback(\n      (event: unknown) => {\n        setIsFocused(false)\n        // @ts-expect-error - React Native event type\n        onBlur?.(event)\n      },\n      [onBlur],\n    )\n\n    const handleKeyDown = React.useCallback(\n      // biome-ignore lint/suspicious/noExplicitAny: Web keyboard event type\n      (event: any) => {\n        if (Platform.OS !== \"web\") return\n        if (isComposingRef.current) return\n\n        if (event.key === \"ArrowDown\") {\n          event.preventDefault()\n          if (!open) {\n            onOpenChange(true)\n          }\n          const nextValue = getNextActiveValue(\"next\")\n          if (nextValue) {\n            setActiveValue(nextValue)\n          }\n        } else if (event.key === \"ArrowUp\") {\n          event.preventDefault()\n          if (!open) {\n            onOpenChange(true)\n          }\n          const nextValue = getNextActiveValue(\"prev\")\n          if (nextValue) {\n            setActiveValue(nextValue)\n          }\n        } else if (event.key === \"Enter\") {\n          if (open && activeValue) {\n            event.preventDefault()\n            const activeItem = filteredItems.find(\n              (item) => item.value === activeValue && !item.disabled,\n            )\n            if (activeItem) {\n              onValueChange(activeValue)\n              onOpenChange(false)\n            }\n          }\n        } else if (event.key === \"Escape\") {\n          if (open) {\n            event.preventDefault()\n            onOpenChange(false)\n          }\n        } else if (event.key === \"Tab\") {\n          if (open) {\n            onOpenChange(false)\n          }\n        }\n\n        onKeyDown?.(event)\n      },\n      [\n        activeValue,\n        filteredItems,\n        getNextActiveValue,\n        onKeyDown,\n        onOpenChange,\n        onValueChange,\n        open,\n        setActiveValue,\n      ],\n    )\n\n    const handleCompositionStart = React.useCallback(\n      (event: unknown) => {\n        isComposingRef.current = true\n        onCompositionStart?.(event)\n      },\n      [onCompositionStart],\n    )\n\n    const handleCompositionEnd = React.useCallback(\n      (event: unknown) => {\n        isComposingRef.current = false\n        onCompositionEnd?.(event)\n      },\n      [onCompositionEnd],\n    )\n\n    const activeDescendantId =\n      activeValue && open ? getItemId(activeValue) : undefined\n\n    return (\n      <TextInput\n        ref={setInputRef}\n        value={inputValue}\n        editable={isDisabled ? false : editable}\n        placeholderTextColor={\n          placeholderTextColor ?? theme.colors.mutedForeground\n        }\n        accessibilityState={{ disabled: isDisabled }}\n        role={Platform.OS === \"web\" ? \"combobox\" : undefined}\n        aria-expanded={Platform.OS === \"web\" ? open : undefined}\n        aria-controls={Platform.OS === \"web\" ? listId : undefined}\n        aria-autocomplete={Platform.OS === \"web\" ? \"list\" : undefined}\n        aria-activedescendant={\n          Platform.OS === \"web\" ? activeDescendantId : undefined\n        }\n        id={Platform.OS === \"web\" ? inputId : undefined}\n        onChangeText={handleChangeText}\n        onFocus={handleFocus}\n        onBlur={handleBlur}\n        // @ts-expect-error - onKeyDown is web-only\n        onKeyDown={Platform.OS === \"web\" ? handleKeyDown : undefined}\n        onCompositionStart={\n          Platform.OS === \"web\" ? handleCompositionStart : undefined\n        }\n        onCompositionEnd={\n          Platform.OS === \"web\" ? handleCompositionEnd : undefined\n        }\n        style={[styles.input, style]}\n        {...props}\n      />\n    )\n  },\n)\n\nComboboxInput.displayName = \"ComboboxInput\"\n\nexport type ComboboxContentProps = ViewProps & {\n  side?: Placement\n  sideOffset?: number\n  align?: \"start\" | \"center\" | \"end\"\n  alignOffset?: number\n  avoidCollisions?: boolean\n  dismissable?: boolean\n  onDismiss?: () => void\n  viewportProps?: ScrollViewProps\n}\n\nexport const ComboboxContent = React.forwardRef<View, ComboboxContentProps>(\n  (\n    {\n      children,\n      side = \"bottom\",\n      sideOffset = 4,\n      align = \"start\",\n      alignOffset = 0,\n      avoidCollisions = true,\n      dismissable = true,\n      onDismiss,\n      style,\n      viewportProps,\n      ...props\n    },\n    ref,\n  ) => {\n    const {\n      open,\n      onOpenChange,\n      anchorRef,\n      contentRef,\n      modal,\n      activeValue,\n      setActiveValue,\n      listId,\n    } = useCombobox()\n\n    const actualPlacement = align === \"center\" ? side : `${side}-${align}`\n\n    const { position, isPositioned } = usePositioning({\n      anchorRef,\n      contentRef,\n      placement: actualPlacement as Placement,\n      offset: sideOffset,\n      alignOffset,\n      flip: avoidCollisions,\n      open,\n    })\n\n    const handleDismiss = React.useCallback(() => {\n      onOpenChange(false)\n      onDismiss?.()\n    }, [onDismiss, onOpenChange])\n\n    const setContentRef = React.useCallback(\n      (node: View | null) => {\n        contentRef.current = node\n        if (typeof ref === \"function\") {\n          ref(node)\n        } else if (ref) {\n          ;(ref as { current: View | null }).current = node\n        }\n      },\n      [contentRef, ref],\n    )\n\n    if (!open) return null\n\n    return (\n      <Portal>\n        <DismissLayer\n          onDismiss={handleDismiss}\n          dismissable={dismissable}\n          scrim={true}\n          scrimStyle={styles.overlay}\n        >\n          <FocusScope trapped={modal} loop={true} style={styles.container}>\n            <View\n              ref={setContentRef}\n              // @ts-expect-error - web-only role\n              role={Platform.OS === \"web\" ? \"listbox\" : undefined}\n              id={Platform.OS === \"web\" ? listId : undefined}\n              style={[\n                styles.content,\n                {\n                  position: \"absolute\",\n                  opacity: isPositioned ? 1 : 0,\n                  top: position.top,\n                  left: position.left,\n                },\n                style,\n              ]}\n              {...props}\n            >\n              <ScrollView\n                keyboardShouldPersistTaps=\"handled\"\n                {...viewportProps}\n                contentContainerStyle={[\n                  styles.viewport,\n                  viewportProps?.contentContainerStyle,\n                ]}\n              >\n                <RovingFocusGroup.RovingFocusGroup\n                  orientation=\"vertical\"\n                  value={activeValue}\n                  onValueChange={setActiveValue}\n                  loop\n                >\n                  {children}\n                </RovingFocusGroup.RovingFocusGroup>\n              </ScrollView>\n            </View>\n          </FocusScope>\n        </DismissLayer>\n      </Portal>\n    )\n  },\n)\n\nComboboxContent.displayName = \"ComboboxContent\"\n\nexport type ComboboxItemProps = Omit<PressableProps, \"children\"> & {\n  children?: React.ReactNode\n  value: string\n  textValue?: string\n  disabled?: boolean\n}\n\nfunction resolveTextValue(children: React.ReactNode, fallback?: string) {\n  if (typeof children === \"string\" || typeof children === \"number\") {\n    return String(children)\n  }\n  if (Array.isArray(children)) {\n    const text = children\n      .map((child) =>\n        typeof child === \"string\" || typeof child === \"number\"\n          ? String(child)\n          : \"\",\n      )\n      .join(\"\")\n    return text || fallback\n  }\n  return fallback\n}\n\nexport const ComboboxItem = React.forwardRef<View, ComboboxItemProps>(\n  ({ value, textValue, disabled, children, style, onPress, ...props }, ref) => {\n    const {\n      value: selectedValue,\n      onValueChange,\n      onOpenChange,\n      registerItem,\n      disabled: comboboxDisabled,\n      inputValue,\n      shouldFilter,\n      filterItem,\n      activeValue,\n      setActiveValue,\n      getItemId,\n    } = useCombobox()\n    const { theme } = useUnistyles()\n    const isSelected = selectedValue === value\n    const isDisabled = !!(disabled || comboboxDisabled)\n    const label = textValue ?? resolveTextValue(children, value) ?? value\n    const isVisible =\n      !shouldFilter ||\n      filterItem(\n        { value, label, disabled: isDisabled, order: 0 },\n        inputValue.trim(),\n      )\n    const itemId = getItemId(value)\n\n    const variantStyles = styles.useVariants({\n      selected: isSelected,\n      active: activeValue === value,\n      disabled: isDisabled,\n    })\n\n    React.useEffect(() => {\n      return registerItem(value, label, isDisabled)\n    }, [isDisabled, label, registerItem, value])\n\n    const handlePress = React.useCallback(\n      (event: unknown) => {\n        if (isDisabled) return\n        onValueChange(value)\n        onOpenChange(false)\n        // @ts-expect-error - React Native event type\n        onPress?.(event)\n      },\n      [isDisabled, onOpenChange, onPress, onValueChange, value],\n    )\n\n    const handleHoverIn = React.useCallback(() => {\n      if (isDisabled) return\n      setActiveValue(value)\n    }, [isDisabled, setActiveValue, value])\n\n    const handleFocus = React.useCallback(() => {\n      if (isDisabled) return\n      setActiveValue(value)\n    }, [isDisabled, setActiveValue, value])\n\n    if (!isVisible) return null\n\n    return (\n      <RovingFocusGroup.RovingFocusItem value={value} disabled={isDisabled} asChild>\n        <Pressable\n          ref={ref}\n          role={Platform.OS === \"web\" ? \"option\" : undefined}\n          aria-selected={Platform.OS === \"web\" ? isSelected : undefined}\n          aria-disabled={Platform.OS === \"web\" ? isDisabled : undefined}\n          id={Platform.OS === \"web\" ? itemId : undefined}\n          accessibilityRole=\"button\"\n          accessibilityState={{ selected: isSelected, disabled: isDisabled }}\n          disabled={isDisabled}\n          onPress={handlePress}\n          onHoverIn={handleHoverIn}\n          onFocus={handleFocus}\n          style={({ pressed }) =>\n            [\n              styles.item,\n              variantStyles,\n              pressed && !isDisabled && styles.itemPressed,\n              typeof style === \"function\" ? style({ pressed }) : style,\n              // biome-ignore lint/suspicious/noExplicitAny: Complex style array with variants requires type assertion\n            ] as any\n          }\n          {...props}\n        >\n          <View style={styles.itemIndicator}>\n            {isSelected && (\n              <Check size={16} color={theme.colors.accentForeground} />\n            )}\n          </View>\n          {typeof children === \"string\" || typeof children === \"number\" ? (\n            <Text style={styles.itemText}>{children}</Text>\n          ) : (\n            children\n          )}\n        </Pressable>\n      </RovingFocusGroup.RovingFocusItem>\n    )\n  },\n)\n\nComboboxItem.displayName = \"ComboboxItem\"\n\nexport type ComboboxEmptyProps = TextProps & {\n  style?: StyleProp<TextStyle>\n}\n\nexport const ComboboxEmpty = React.forwardRef<Text, ComboboxEmptyProps>(\n  ({ style, children, ...props }, ref) => {\n    const { filteredItems, open } = useCombobox()\n    if (!open || filteredItems.length > 0) return null\n    return (\n      <Text ref={ref} style={[styles.empty, style]} {...props}>\n        {children}\n      </Text>\n    )\n  },\n)\n\nComboboxEmpty.displayName = \"ComboboxEmpty\"\n\nexport type ComboboxGroupProps = ViewProps\n\nexport const ComboboxGroup = React.forwardRef<View, ComboboxGroupProps>(\n  ({ style, ...props }, ref) => {\n    return <View ref={ref} style={[styles.group, style]} {...props} />\n  },\n)\n\nComboboxGroup.displayName = \"ComboboxGroup\"\n\nexport type ComboboxLabelProps = TextProps & {\n  style?: StyleProp<TextStyle>\n}\n\nexport const ComboboxLabel = React.forwardRef<Text, ComboboxLabelProps>(\n  ({ style, ...props }, ref) => {\n    return <Text ref={ref} style={[styles.label, style]} {...props} />\n  },\n)\n\nComboboxLabel.displayName = \"ComboboxLabel\"\n\nexport type ComboboxSeparatorProps = ViewProps & {\n  style?: StyleProp<ViewStyle>\n}\n\nexport const ComboboxSeparator = React.forwardRef<View, ComboboxSeparatorProps>(\n  ({ style, ...props }, ref) => {\n    return <View ref={ref} style={[styles.separator, style]} {...props} />\n  },\n)\n\nComboboxSeparator.displayName = \"ComboboxSeparator\"\n\nconst styles = StyleSheet.create((theme) => ({\n  container: {\n    flex: 1,\n  },\n  overlay: {\n    backgroundColor: \"transparent\",\n  },\n  input: {\n    height: theme.spacing[10],\n    width: \"100%\",\n    borderRadius: theme.radius.md,\n    borderWidth: 1,\n    borderColor: theme.colors.input,\n    backgroundColor: theme.colors.background,\n    paddingHorizontal: theme.spacing[3],\n    paddingVertical: theme.spacing[2],\n    fontSize: theme.typography.sizes.sm,\n    lineHeight: theme.typography.lineHeights.sm,\n    color: theme.colors.foreground,\n    variants: {\n      focused: {\n        true: {\n          borderColor: theme.colors.ring,\n          shadowColor: theme.colors.ring,\n          shadowOpacity: 0.35,\n          shadowRadius: 4,\n          shadowOffset: { width: 0, height: 0 },\n        },\n      },\n      disabled: {\n        true: {\n          opacity: 0.6,\n        },\n      },\n    },\n  },\n  content: {\n    zIndex: 50,\n    minWidth: 180,\n    borderRadius: theme.radius.md,\n    borderWidth: 1,\n    borderColor: theme.colors.border,\n    backgroundColor: theme.colors.popover,\n    paddingVertical: theme.spacing[2],\n    shadowColor: theme.colors.foreground,\n    shadowOpacity: 0.1,\n    shadowRadius: 6,\n    elevation: 3,\n    maxHeight: 300,\n  },\n  viewport: {\n    paddingHorizontal: theme.spacing[1],\n    gap: theme.spacing[1],\n  },\n  item: {\n    minHeight: theme.spacing[8],\n    paddingHorizontal: theme.spacing[3],\n    paddingVertical: theme.spacing[2],\n    borderRadius: theme.radius.sm,\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: theme.spacing[2],\n    variants: {\n      active: {\n        true: {\n          backgroundColor: theme.colors.muted,\n        },\n      },\n      selected: {\n        true: {\n          backgroundColor: theme.colors.accent,\n        },\n      },\n      disabled: {\n        true: {\n          opacity: 0.5,\n        },\n      },\n    },\n  },\n  itemPressed: {\n    backgroundColor: theme.colors.muted,\n  },\n  itemIndicator: {\n    width: 18,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  itemText: {\n    fontSize: theme.typography.sizes.sm,\n    lineHeight: theme.typography.lineHeights.sm,\n    color: theme.colors.popoverForeground,\n  },\n  group: {\n    gap: theme.spacing[1],\n    paddingVertical: theme.spacing[1],\n  },\n  label: {\n    paddingHorizontal: theme.spacing[3],\n    paddingVertical: theme.spacing[1],\n    fontSize: theme.typography.sizes.xs,\n    textTransform: \"uppercase\",\n    letterSpacing: 0.5,\n    color: theme.colors.mutedForeground,\n  },\n  separator: {\n    height: 1,\n    backgroundColor: theme.colors.border,\n    marginVertical: theme.spacing[1],\n  },\n  empty: {\n    paddingHorizontal: theme.spacing[3],\n    paddingVertical: theme.spacing[2],\n    fontSize: theme.typography.sizes.sm,\n    lineHeight: theme.typography.lineHeights.sm,\n    color: theme.colors.mutedForeground,\n  },\n}))\n",
      "type": "registry:ui"
    }
  ]
}
