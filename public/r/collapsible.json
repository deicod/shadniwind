{
  "name": "collapsible",
  "type": "registry:ui",
  "title": "Collapsible",
  "description": "An interactive component which expands/collapses content with animated height transitions. Single-item accordion pattern.",
  "registryDependencies": [
    "tokens"
  ],
  "files": [
    {
      "path": "components/ui/collapsible.tsx",
      "content": "import * as React from \"react\"\nimport {\n  Animated,\n  Platform,\n  Pressable,\n  type PressableProps,\n  View,\n  type ViewProps,\n} from \"react-native\"\nimport { StyleSheet } from \"react-native-unistyles\"\n\ntype CollapsibleContextValue = {\n  open: boolean\n  onOpenChange: (open: boolean) => void\n}\n\nconst CollapsibleContext = React.createContext<\n  CollapsibleContextValue | undefined\n>(undefined)\n\nfunction useCollapsible() {\n  const context = React.useContext(CollapsibleContext)\n  if (!context) {\n    throw new Error(\"Collapsible components must be used within Collapsible\")\n  }\n  return context\n}\n\nexport type CollapsibleProps = ViewProps & {\n  open?: boolean\n  defaultOpen?: boolean\n  onOpenChange?: (open: boolean) => void\n  disabled?: boolean\n}\n\nexport const Collapsible = React.forwardRef<\n  React.ComponentRef<typeof View>,\n  CollapsibleProps\n>(\n  (\n    {\n      open: openProp,\n      defaultOpen = false,\n      onOpenChange,\n      disabled = false,\n      children,\n      ...props\n    },\n    ref,\n  ) => {\n    const [uncontrolledOpen, setUncontrolledOpen] =\n      React.useState<boolean>(defaultOpen)\n\n    const isControlled = openProp !== undefined\n    const open = isControlled ? openProp : uncontrolledOpen\n\n    const handleOpenChange = React.useCallback(\n      (newOpen: boolean) => {\n        if (disabled) return\n\n        if (!isControlled) {\n          setUncontrolledOpen(newOpen)\n        }\n\n        onOpenChange?.(newOpen)\n      },\n      [disabled, isControlled, onOpenChange],\n    )\n\n    return (\n      <CollapsibleContext.Provider\n        value={{ open, onOpenChange: handleOpenChange }}\n      >\n        <View ref={ref} {...props}>\n          {children}\n        </View>\n      </CollapsibleContext.Provider>\n    )\n  },\n)\n\nCollapsible.displayName = \"Collapsible\"\n\nexport type CollapsibleTriggerProps = PressableProps\n\nexport const CollapsibleTrigger = React.forwardRef<\n  React.ComponentRef<typeof Pressable>,\n  CollapsibleTriggerProps\n>(({ onPress, children, ...props }, ref) => {\n  const { open, onOpenChange } = useCollapsible()\n\n  const handlePress = React.useCallback(\n    // biome-ignore lint/suspicious/noExplicitAny: Event handler type\n    (event: any) => {\n      onOpenChange(!open)\n      onPress?.(event)\n    },\n    [open, onOpenChange, onPress],\n  )\n\n  return (\n    <Pressable\n      ref={ref}\n      role={Platform.OS === \"web\" ? \"button\" : undefined}\n      aria-expanded={Platform.OS === \"web\" ? open : undefined}\n      accessible={true}\n      accessibilityRole=\"button\"\n      accessibilityState={{\n        expanded: open,\n      }}\n      onPress={handlePress}\n      {...props}\n    >\n      {children}\n    </Pressable>\n  )\n})\n\nCollapsibleTrigger.displayName = \"CollapsibleTrigger\"\n\nexport type CollapsibleContentProps = ViewProps\n\nexport const CollapsibleContent = React.forwardRef<\n  React.ComponentRef<typeof View>,\n  CollapsibleContentProps\n>(({ children, style, ...props }, ref) => {\n  const { open } = useCollapsible()\n  const animatedHeight = React.useRef(new Animated.Value(open ? 1 : 0)).current\n  const [contentHeight, setContentHeight] = React.useState<number>(0)\n\n  React.useEffect(() => {\n    Animated.timing(animatedHeight, {\n      toValue: open ? 1 : 0,\n      duration: 200,\n      useNativeDriver: false,\n    }).start()\n  }, [open, animatedHeight])\n\n  const handleLayout = React.useCallback(\n    // biome-ignore lint/suspicious/noExplicitAny: Layout event type\n    (event: any) => {\n      const { height } = event.nativeEvent.layout\n      if (height > 0 && height !== contentHeight) {\n        setContentHeight(height)\n      }\n    },\n    [contentHeight],\n  )\n\n  const heightInterpolation = animatedHeight.interpolate({\n    inputRange: [0, 1],\n    outputRange: [0, contentHeight],\n  })\n\n  // Always measure content height before rendering animated view\n  if (contentHeight === 0) {\n    return (\n      <View onLayout={handleLayout} style={[styles.measuringContainer, style]}>\n        {children}\n      </View>\n    )\n  }\n\n  return (\n    <Animated.View\n      ref={ref}\n      role={Platform.OS === \"web\" ? \"region\" : undefined}\n      style={[\n        styles.content,\n        {\n          height: heightInterpolation,\n          opacity: animatedHeight,\n        },\n        style,\n      ]}\n      {...props}\n    >\n      <View onLayout={handleLayout}>{children}</View>\n    </Animated.View>\n  )\n})\n\nCollapsibleContent.displayName = \"CollapsibleContent\"\n\nconst styles = StyleSheet.create(() => ({\n  content: {\n    overflow: \"hidden\",\n  },\n  measuringContainer: {\n    position: \"absolute\",\n    opacity: 0,\n    zIndex: -1,\n  },\n}))\n",
      "type": "registry:ui"
    }
  ]
}
