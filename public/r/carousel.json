{
  "name": "carousel",
  "type": "registry:ui",
  "title": "Carousel",
  "description": "Swipeable carousel with snapping and keyboard navigation on web.",
  "registryDependencies": [
    "@shadniwind/tokens"
  ],
  "files": [
    {
      "path": "components/ui/carousel.tsx",
      "content": "import * as React from \"react\"\nimport {\n  Platform,\n  Pressable,\n  type PressableProps,\n  ScrollView,\n  type ScrollViewProps,\n  type LayoutChangeEvent,\n  type NativeScrollEvent,\n  type NativeSyntheticEvent,\n  type StyleProp,\n  Text,\n  View,\n  type ViewProps,\n  type ViewStyle,\n  type TextStyle,\n} from \"react-native\"\nimport { StyleSheet } from \"react-native-unistyles\"\n\ntype CarouselOrientation = \"horizontal\" | \"vertical\"\n\ntype CarouselContextValue = {\n  orientation: CarouselOrientation\n  itemSize?: number\n  itemSpacing: number\n  loop: boolean\n  currentIndex: number\n  itemCount: number\n  snapInterval: number\n  containerSize: number\n  setContainerSize: (size: number) => void\n  setItemCount: (count: number) => void\n  scrollRef: React.RefObject<ScrollView | null>\n  scrollToIndex: (index: number, options?: { animated?: boolean }) => void\n  handleIndexChange: (index: number) => void\n}\n\nconst CarouselContext = React.createContext<CarouselContextValue | null>(null)\n\nfunction useCarousel() {\n  const context = React.useContext(CarouselContext)\n  if (!context) {\n    throw new Error(\"Carousel components must be used within a Carousel\")\n  }\n  return context\n}\n\nfunction clamp(value: number, min: number, max: number) {\n  return Math.min(Math.max(value, min), max)\n}\n\nexport type CarouselProps = ViewProps & {\n  index?: number\n  defaultIndex?: number\n  onIndexChange?: (index: number) => void\n  itemSize?: number\n  itemSpacing?: number\n  orientation?: CarouselOrientation\n  loop?: boolean\n}\n\n/**\n * Carousel component for swipeable, snapped paging.\n *\n * Native: swipe gestures via ScrollView.\n * Web: arrow key navigation when focused.\n *\n * Limitations:\n * - Assumes uniform item size (snapToInterval).\n * - No virtualization; keep item counts modest.\n */\nexport const Carousel = React.forwardRef<View, CarouselProps>(\n  (\n    {\n      index: indexProp,\n      defaultIndex = 0,\n      onIndexChange,\n      itemSize,\n      itemSpacing = 0,\n      orientation = \"horizontal\",\n      loop = false,\n      style,\n      children,\n      ...props\n    },\n    ref,\n  ) => {\n    const [uncontrolledIndex, setUncontrolledIndex] =\n      React.useState(defaultIndex)\n    const [containerSize, setContainerSize] = React.useState(0)\n    const [itemCount, setItemCount] = React.useState(0)\n    const scrollRef = React.useRef<ScrollView | null>(null)\n\n    const isControlled = indexProp !== undefined\n    const currentIndex = isControlled ? indexProp : uncontrolledIndex\n\n    const snapInterval = React.useMemo(() => {\n      const size = itemSize ?? containerSize\n      if (!Number.isFinite(size) || size <= 0) return 0\n      return size + itemSpacing\n    }, [itemSize, containerSize, itemSpacing])\n\n    const handleIndexChange = React.useCallback(\n      (nextIndex: number) => {\n        const maxIndex = Math.max(itemCount - 1, 0)\n        const resolvedIndex =\n          loop && itemCount > 0\n            ? ((nextIndex % itemCount) + itemCount) % itemCount\n            : clamp(nextIndex, 0, maxIndex)\n\n        if (!isControlled) {\n          setUncontrolledIndex(resolvedIndex)\n        }\n        onIndexChange?.(resolvedIndex)\n      },\n      [isControlled, itemCount, loop, onIndexChange],\n    )\n\n    const scrollToIndex = React.useCallback(\n      (nextIndex: number, options?: { animated?: boolean }) => {\n        if (itemCount <= 0) {\n          handleIndexChange(0)\n          return\n        }\n\n        const resolvedIndex = loop\n          ? ((nextIndex % itemCount) + itemCount) % itemCount\n          : clamp(nextIndex, 0, itemCount - 1)\n\n        handleIndexChange(resolvedIndex)\n\n        if (snapInterval <= 0) return\n\n        const offset = snapInterval * resolvedIndex\n        scrollRef.current?.scrollTo({\n          x: orientation === \"horizontal\" ? offset : 0,\n          y: orientation === \"horizontal\" ? 0 : offset,\n          animated: options?.animated ?? true,\n        })\n      },\n      [handleIndexChange, itemCount, loop, snapInterval, orientation],\n    )\n\n    React.useEffect(() => {\n      if (itemCount <= 0) return\n      if (currentIndex > itemCount - 1) {\n        handleIndexChange(itemCount - 1)\n      }\n    }, [currentIndex, handleIndexChange, itemCount])\n\n    return (\n      <CarouselContext.Provider\n        value={{\n          orientation,\n          itemSize,\n          itemSpacing,\n          loop,\n          currentIndex,\n          itemCount,\n          snapInterval,\n          containerSize,\n          setContainerSize,\n          setItemCount,\n          scrollRef,\n          scrollToIndex,\n          handleIndexChange,\n        }}\n      >\n        <View ref={ref} style={[styles.root, style]} {...props}>\n          {children}\n        </View>\n      </CarouselContext.Provider>\n    )\n  },\n)\n\nCarousel.displayName = \"Carousel\"\n\nexport type CarouselContentProps = Omit<ScrollViewProps, \"horizontal\"> & {\n  onKeyDown?: (event: unknown) => void\n}\n\nexport const CarouselContent = React.forwardRef<\n  React.ComponentRef<typeof ScrollView>,\n  CarouselContentProps\n>(\n  (\n    {\n      style,\n      contentContainerStyle,\n      onLayout,\n      onMomentumScrollEnd,\n      onScrollEndDrag,\n      onKeyDown,\n      snapToInterval: snapToIntervalProp,\n      snapToAlignment: snapToAlignmentProp,\n      pagingEnabled: pagingEnabledProp,\n      decelerationRate: decelerationRateProp,\n      showsHorizontalScrollIndicator = false,\n      showsVerticalScrollIndicator = false,\n      children,\n      ...props\n    },\n    ref,\n  ) => {\n    const {\n      orientation,\n      itemSize,\n      itemSpacing,\n      snapInterval,\n      containerSize,\n      setContainerSize,\n      setItemCount,\n      scrollRef,\n      scrollToIndex,\n      handleIndexChange,\n      currentIndex,\n    } = useCarousel()\n\n    const isHorizontal = orientation === \"horizontal\"\n\n    const setScrollRef = React.useCallback(\n      (node: React.ComponentRef<typeof ScrollView> | null) => {\n        scrollRef.current = node\n        if (typeof ref === \"function\") {\n          ref(node)\n        } else if (ref) {\n          ;(\n            ref as React.MutableRefObject<\n              React.ComponentRef<typeof ScrollView> | null\n            >\n          ).current = node\n        }\n      },\n      [ref, scrollRef],\n    )\n\n    const handleLayout = React.useCallback(\n      (event: LayoutChangeEvent) => {\n        const size = isHorizontal\n          ? event.nativeEvent.layout.width\n          : event.nativeEvent.layout.height\n        setContainerSize(size)\n        onLayout?.(event)\n      },\n      [isHorizontal, onLayout, setContainerSize],\n    )\n\n    const childCount = React.Children.count(children)\n\n    React.useEffect(() => {\n      setItemCount(childCount)\n    }, [childCount, setItemCount])\n\n    React.useEffect(() => {\n      if (snapInterval <= 0) return\n      const offset = snapInterval * currentIndex\n      scrollRef.current?.scrollTo({\n        x: isHorizontal ? offset : 0,\n        y: isHorizontal ? 0 : offset,\n        animated: false,\n      })\n    }, [currentIndex, isHorizontal, snapInterval, scrollRef])\n\n    const handleScrollEnd = React.useCallback(\n      (event: NativeSyntheticEvent<NativeScrollEvent>) => {\n        if (snapInterval > 0) {\n          const offset = isHorizontal\n            ? event.nativeEvent.contentOffset.x\n            : event.nativeEvent.contentOffset.y\n          const nextIndex = Math.round(offset / snapInterval)\n          handleIndexChange(nextIndex)\n        }\n        onMomentumScrollEnd?.(event)\n      },\n      [handleIndexChange, isHorizontal, onMomentumScrollEnd, snapInterval],\n    )\n\n    const handleScrollEndDrag = React.useCallback(\n      (event: NativeSyntheticEvent<NativeScrollEvent>) => {\n        if (snapInterval > 0) {\n          const offset = isHorizontal\n            ? event.nativeEvent.contentOffset.x\n            : event.nativeEvent.contentOffset.y\n          const nextIndex = Math.round(offset / snapInterval)\n          handleIndexChange(nextIndex)\n        }\n        onScrollEndDrag?.(event)\n      },\n      [handleIndexChange, isHorizontal, onScrollEndDrag, snapInterval],\n    )\n\n    const handleKeyDown = React.useCallback(\n      (event: {\n        key?: string\n        preventDefault?: () => void\n        defaultPrevented?: boolean\n      }) => {\n        onKeyDown?.(event)\n        if (event.defaultPrevented) return\n\n        const prevKey = isHorizontal ? \"ArrowLeft\" : \"ArrowUp\"\n        const nextKey = isHorizontal ? \"ArrowRight\" : \"ArrowDown\"\n\n        if (event.key === prevKey) {\n          event.preventDefault?.()\n          scrollToIndex(currentIndex - 1)\n        }\n        if (event.key === nextKey) {\n          event.preventDefault?.()\n          scrollToIndex(currentIndex + 1)\n        }\n      },\n      [currentIndex, isHorizontal, onKeyDown, scrollToIndex],\n    )\n\n    const shouldPage =\n      snapInterval > 0 &&\n      itemSpacing === 0 &&\n      (itemSize ?? containerSize) === containerSize\n    const resolvedPagingEnabled = pagingEnabledProp ?? shouldPage\n    const resolvedSnapToInterval =\n      snapToIntervalProp ?? (resolvedPagingEnabled ? undefined : snapInterval || undefined)\n    const resolvedDecelerationRate =\n      decelerationRateProp ?? (snapInterval > 0 ? \"fast\" : undefined)\n\n    const contentStyle: StyleProp<ViewStyle> = [\n      styles.content,\n      isHorizontal ? styles.contentHorizontal : styles.contentVertical,\n      contentContainerStyle,\n    ]\n\n    return (\n      <ScrollView\n        ref={setScrollRef}\n        horizontal={isHorizontal}\n        style={[styles.viewport, style]}\n        contentContainerStyle={contentStyle}\n        showsHorizontalScrollIndicator={showsHorizontalScrollIndicator}\n        showsVerticalScrollIndicator={showsVerticalScrollIndicator}\n        decelerationRate={resolvedDecelerationRate}\n        pagingEnabled={resolvedPagingEnabled}\n        snapToInterval={resolvedSnapToInterval}\n        snapToAlignment={snapToAlignmentProp}\n        onLayout={handleLayout}\n        onMomentumScrollEnd={handleScrollEnd}\n        onScrollEndDrag={handleScrollEndDrag}\n        role={Platform.OS === \"web\" ? \"region\" : undefined}\n        tabIndex={Platform.OS === \"web\" ? 0 : undefined}\n        // @ts-expect-error - onKeyDown is web-only\n        onKeyDown={Platform.OS === \"web\" ? handleKeyDown : undefined}\n        {...props}\n      >\n        {children}\n      </ScrollView>\n    )\n  },\n)\n\nCarouselContent.displayName = \"CarouselContent\"\n\nexport type CarouselItemProps = ViewProps\n\nexport const CarouselItem = React.forwardRef<View, CarouselItemProps>(\n  ({ style, ...props }, ref) => {\n    const { orientation, itemSize, containerSize, itemSpacing } = useCarousel()\n    const isHorizontal = orientation === \"horizontal\"\n    const size = itemSize ?? containerSize\n\n    const sizeStyle: ViewStyle = isHorizontal\n      ? { width: size > 0 ? size : \"100%\" }\n      : { height: size > 0 ? size : \"100%\" }\n\n    const spacingStyle: ViewStyle = isHorizontal\n      ? { marginRight: itemSpacing }\n      : { marginBottom: itemSpacing }\n\n    return (\n      <View\n        ref={ref}\n        style={[styles.item, sizeStyle, spacingStyle, style]}\n        {...props}\n      />\n    )\n  },\n)\n\nCarouselItem.displayName = \"CarouselItem\"\n\nexport type CarouselControlProps = PressableProps & {\n  disabled?: boolean\n  textStyle?: StyleProp<TextStyle>\n}\n\nexport const CarouselPrevious = React.forwardRef<\n  React.ComponentRef<typeof Pressable>,\n  CarouselControlProps\n>(({ style, textStyle, disabled, children, ...props }, ref) => {\n  const { currentIndex, itemCount, loop, orientation, scrollToIndex } =\n    useCarousel()\n  const isHorizontal = orientation === \"horizontal\"\n  const autoDisabled =\n    itemCount <= 0 ? true : !loop && currentIndex <= 0\n  const isDisabled = disabled ?? autoDisabled\n  const variantStyles = styles.useVariants({ disabled: isDisabled })\n\n  return (\n    <Pressable\n      ref={ref}\n      role={Platform.OS === \"web\" ? \"button\" : undefined}\n      accessibilityRole=\"button\"\n      accessibilityState={{ disabled: isDisabled }}\n      onPress={() => {\n        if (isDisabled) return\n        scrollToIndex(currentIndex - 1)\n      }}\n      disabled={isDisabled}\n      style={({ pressed }) =>\n        [\n          styles.control,\n          isHorizontal ? styles.controlPrev : styles.controlUp,\n          variantStyles,\n          pressed && !isDisabled && styles.controlPressed,\n          typeof style === \"function\" ? style({ pressed }) : style,\n          // biome-ignore lint/suspicious/noExplicitAny: Style array type assertion\n        ] as any\n      }\n      {...props}\n    >\n      {children ?? <Text style={[styles.controlText, textStyle]}>Prev</Text>}\n    </Pressable>\n  )\n})\n\nCarouselPrevious.displayName = \"CarouselPrevious\"\n\nexport const CarouselNext = React.forwardRef<\n  React.ComponentRef<typeof Pressable>,\n  CarouselControlProps\n>(({ style, textStyle, disabled, children, ...props }, ref) => {\n  const { currentIndex, itemCount, loop, orientation, scrollToIndex } =\n    useCarousel()\n  const isHorizontal = orientation === \"horizontal\"\n  const autoDisabled =\n    itemCount <= 0 ? true : !loop && currentIndex >= itemCount - 1\n  const isDisabled = disabled ?? autoDisabled\n  const variantStyles = styles.useVariants({ disabled: isDisabled })\n\n  return (\n    <Pressable\n      ref={ref}\n      role={Platform.OS === \"web\" ? \"button\" : undefined}\n      accessibilityRole=\"button\"\n      accessibilityState={{ disabled: isDisabled }}\n      onPress={() => {\n        if (isDisabled) return\n        scrollToIndex(currentIndex + 1)\n      }}\n      disabled={isDisabled}\n      style={({ pressed }) =>\n        [\n          styles.control,\n          isHorizontal ? styles.controlNext : styles.controlDown,\n          variantStyles,\n          pressed && !isDisabled && styles.controlPressed,\n          typeof style === \"function\" ? style({ pressed }) : style,\n          // biome-ignore lint/suspicious/noExplicitAny: Style array type assertion\n        ] as any\n      }\n      {...props}\n    >\n      {children ?? <Text style={[styles.controlText, textStyle]}>Next</Text>}\n    </Pressable>\n  )\n})\n\nCarouselNext.displayName = \"CarouselNext\"\n\nconst styles = StyleSheet.create((theme) => ({\n  root: {\n    position: \"relative\",\n    width: \"100%\",\n  },\n  viewport: {\n    width: \"100%\",\n  },\n  content: {\n    alignItems: \"stretch\",\n  },\n  contentHorizontal: {\n    flexDirection: \"row\",\n  },\n  contentVertical: {\n    flexDirection: \"column\",\n  },\n  item: {\n    flexGrow: 0,\n    flexShrink: 0,\n  },\n  control: {\n    position: \"absolute\",\n    width: 32,\n    height: 32,\n    borderRadius: 16,\n    borderWidth: 1,\n    borderColor: theme.colors.border,\n    backgroundColor: theme.colors.background,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    variants: {\n      disabled: {\n        true: {\n          opacity: 0.5,\n        },\n      },\n    },\n  },\n  controlPressed: {\n    opacity: 0.8,\n  },\n  controlText: {\n    fontSize: theme.typography.sizes.sm,\n    color: theme.colors.foreground,\n  },\n  controlPrev: {\n    left: theme.spacing[2],\n    top: \"50%\",\n    transform: [{ translateY: -16 }],\n  },\n  controlNext: {\n    right: theme.spacing[2],\n    top: \"50%\",\n    transform: [{ translateY: -16 }],\n  },\n  controlUp: {\n    top: theme.spacing[2],\n    left: \"50%\",\n    transform: [{ translateX: -16 }],\n  },\n  controlDown: {\n    bottom: theme.spacing[2],\n    left: \"50%\",\n    transform: [{ translateX: -16 }],\n  },\n}))\n",
      "type": "registry:ui"
    }
  ]
}
