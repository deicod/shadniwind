{
  "name": "command",
  "type": "registry:ui",
  "title": "Command",
  "description": "Command palette with input filtering and keyboard navigation.",
  "registryDependencies": [
    "@shadniwind/tokens",
    "@shadniwind/roving-focus"
  ],
  "files": [
    {
      "path": "components/ui/command.tsx",
      "content": "import * as React from \"react\"\nimport {\n  Platform,\n  Pressable,\n  type PressableProps,\n  ScrollView,\n  type ScrollViewProps,\n  type StyleProp,\n  Text,\n  type TextProps,\n  TextInput,\n  type TextInputProps,\n  type TextStyle,\n  View,\n  type ViewProps,\n  type ViewStyle,\n} from \"react-native\"\nimport { StyleSheet, useUnistyles } from \"react-native-unistyles\"\nimport * as RovingFocusGroup from \"../primitives/roving-focus/index\"\n\ntype CommandItemData = {\n  value: string\n  label: string\n  disabled?: boolean\n  order: number\n}\n\ntype CommandFilter = (item: CommandItemData, query: string) => boolean\n\ntype CommandContextValue = {\n  query: string\n  setQuery: (value: string) => void\n  shouldFilter: boolean\n  filterItem: CommandFilter\n  registerItem: (value: string, label: string, disabled?: boolean) => () => void\n  filteredItems: CommandItemData[]\n  activeValue?: string\n  setActiveValue: (value?: string) => void\n  listId: string\n  inputId: string\n  getItemId: (value: string) => string\n  setItemAction: (value: string, action?: (value: string) => void) => void\n  runItemAction: (value: string) => void\n}\n\nconst CommandContext = React.createContext<CommandContextValue | undefined>(\n  undefined,\n)\n\nfunction useCommand() {\n  const context = React.useContext(CommandContext)\n  if (!context) {\n    throw new Error(\"Command components must be used within Command\")\n  }\n  return context\n}\n\nexport type CommandProps = ViewProps & {\n  value?: string\n  defaultValue?: string\n  onValueChange?: (value: string) => void\n  shouldFilter?: boolean\n  filter?: CommandFilter\n}\n\nexport const Command = React.forwardRef<View, CommandProps>(\n  (\n    {\n      value: valueProp,\n      defaultValue,\n      onValueChange,\n      shouldFilter = true,\n      filter,\n      style,\n      ...props\n    },\n    ref,\n  ) => {\n    const [query, setQuery] = React.useState(valueProp ?? defaultValue ?? \"\")\n    const [activeValue, setActiveValue] = React.useState<string | undefined>(\n      undefined,\n    )\n    const [itemsVersion, setItemsVersion] = React.useState(0)\n    const itemsRef = React.useRef<Map<string, CommandItemData>>(new Map())\n    const orderRef = React.useRef(0)\n    const orderMapRef = React.useRef<Map<string, number>>(new Map())\n    const itemActionRef = React.useRef<Map<string, (value: string) => void>>(\n      new Map(),\n    )\n    const listId = React.useId()\n    const inputId = React.useId()\n\n    const isControlled = valueProp !== undefined\n    const currentQuery = isControlled ? valueProp ?? \"\" : query\n\n    const filterItem = React.useCallback<CommandFilter>(\n      (item, search) => {\n        if (!search) return true\n        return item.label.toLowerCase().includes(search.toLowerCase())\n      },\n      [],\n    )\n\n    const activeFilter = filter ?? filterItem\n\n    const items = React.useMemo(() => {\n      const currentVersion = itemsVersion\n      void currentVersion\n      return Array.from(itemsRef.current.values()).sort(\n        (a, b) => a.order - b.order,\n      )\n    }, [itemsVersion])\n\n    const filteredItems = React.useMemo(() => {\n      if (!shouldFilter) return items\n      const search = currentQuery.trim()\n      if (!search) return items\n      return items.filter((item) => activeFilter(item, search))\n    }, [activeFilter, currentQuery, items, shouldFilter])\n\n    const registerItem = React.useCallback(\n      (itemValue: string, label: string, itemDisabled?: boolean) => {\n        const existingOrder = orderMapRef.current.get(itemValue)\n        const order = existingOrder ?? orderRef.current++\n        orderMapRef.current.set(itemValue, order)\n        itemsRef.current.set(itemValue, {\n          value: itemValue,\n          label,\n          disabled: itemDisabled,\n          order,\n        })\n        setItemsVersion((prev) => prev + 1)\n\n        return () => {\n          itemsRef.current.delete(itemValue)\n          setItemsVersion((prev) => prev + 1)\n        }\n      },\n      [],\n    )\n\n    const getItemId = React.useCallback(\n      (value: string) => `${listId}-item-${encodeURIComponent(value)}`,\n      [listId],\n    )\n\n    const setItemAction = React.useCallback(\n      (value: string, action?: (value: string) => void) => {\n        if (action) {\n          itemActionRef.current.set(value, action)\n        } else {\n          itemActionRef.current.delete(value)\n        }\n      },\n      [],\n    )\n\n    const runItemAction = React.useCallback((value: string) => {\n      itemActionRef.current.get(value)?.(value)\n    }, [])\n\n    const handleQueryChange = React.useCallback(\n      (nextValue: string) => {\n        if (!isControlled) {\n          setQuery(nextValue)\n        }\n        onValueChange?.(nextValue)\n      },\n      [isControlled, onValueChange],\n    )\n\n    React.useEffect(() => {\n      if (filteredItems.length === 0) {\n        setActiveValue(undefined)\n        return\n      }\n      if (activeValue && filteredItems.some((item) => item.value === activeValue)) {\n        return\n      }\n      const firstEnabled = filteredItems.find((item) => !item.disabled)\n      if (firstEnabled) {\n        setActiveValue(firstEnabled.value)\n      }\n    }, [activeValue, filteredItems])\n\n    return (\n      <CommandContext.Provider\n        value={{\n          query: currentQuery,\n          setQuery: handleQueryChange,\n          shouldFilter,\n          filterItem: activeFilter,\n          registerItem,\n          filteredItems,\n          activeValue,\n          setActiveValue,\n          listId,\n          inputId,\n          getItemId,\n          setItemAction,\n          runItemAction,\n        }}\n      >\n        <View ref={ref} style={[styles.container, style]} {...props} />\n      </CommandContext.Provider>\n    )\n  },\n)\n\nCommand.displayName = \"Command\"\n\nexport type CommandInputProps = Omit<\n  TextInputProps,\n  \"value\" | \"defaultValue\" | \"onChangeText\"\n> & {\n  onChangeText?: TextInputProps[\"onChangeText\"]\n  onKeyDown?: (event: unknown) => void\n  style?: StyleProp<TextStyle>\n}\n\nexport const CommandInput = React.forwardRef<TextInput, CommandInputProps>(\n  (\n    {\n      onChangeText,\n      onKeyDown,\n      onFocus,\n      onBlur,\n      placeholderTextColor,\n      style,\n      ...props\n    },\n    ref,\n  ) => {\n    const {\n      query,\n      setQuery,\n      listId,\n      inputId,\n      activeValue,\n      setActiveValue,\n      filteredItems,\n      getItemId,\n      runItemAction,\n    } = useCommand()\n    const { theme } = useUnistyles()\n    const [isFocused, setIsFocused] = React.useState(false)\n\n    styles.useVariants({\n      focused: isFocused,\n    })\n\n    const handleChangeText = React.useCallback(\n      (text: string) => {\n        setQuery(text)\n        onChangeText?.(text)\n      },\n      [onChangeText, setQuery],\n    )\n\n    const getNextActiveValue = React.useCallback(\n      (direction: \"next\" | \"prev\") => {\n        const enabledItems = filteredItems.filter((item) => !item.disabled)\n        if (enabledItems.length === 0) return undefined\n        const currentIndex = enabledItems.findIndex(\n          (item) => item.value === activeValue,\n        )\n        if (currentIndex === -1) {\n          return direction === \"next\"\n            ? enabledItems[0]?.value\n            : enabledItems[enabledItems.length - 1]?.value\n        }\n        const nextIndex =\n          direction === \"next\"\n            ? Math.min(currentIndex + 1, enabledItems.length - 1)\n            : Math.max(currentIndex - 1, 0)\n        return enabledItems[nextIndex]?.value\n      },\n      [activeValue, filteredItems],\n    )\n\n    const handleKeyDown = React.useCallback(\n      // biome-ignore lint/suspicious/noExplicitAny: Web keyboard event type\n      (event: any) => {\n        if (Platform.OS !== \"web\") return\n        if (event.key === \"ArrowDown\") {\n          event.preventDefault()\n          const nextValue = getNextActiveValue(\"next\")\n          if (nextValue) {\n            setActiveValue(nextValue)\n          }\n        } else if (event.key === \"ArrowUp\") {\n          event.preventDefault()\n          const nextValue = getNextActiveValue(\"prev\")\n          if (nextValue) {\n            setActiveValue(nextValue)\n          }\n        } else if (event.key === \"Enter\") {\n          if (activeValue) {\n            event.preventDefault()\n            runItemAction(activeValue)\n          }\n        }\n        onKeyDown?.(event)\n      },\n      [activeValue, getNextActiveValue, onKeyDown, runItemAction, setActiveValue],\n    )\n\n    const handleFocus = React.useCallback(\n      (event: unknown) => {\n        setIsFocused(true)\n        // @ts-expect-error - React Native event type\n        onFocus?.(event)\n      },\n      [onFocus],\n    )\n\n    const handleBlur = React.useCallback(\n      (event: unknown) => {\n        setIsFocused(false)\n        // @ts-expect-error - React Native event type\n        onBlur?.(event)\n      },\n      [onBlur],\n    )\n\n    const activeDescendantId =\n      Platform.OS === \"web\" && activeValue ? getItemId(activeValue) : undefined\n\n    return (\n      <TextInput\n        ref={ref}\n        value={query}\n        placeholderTextColor={\n          placeholderTextColor ?? theme.colors.mutedForeground\n        }\n        role={Platform.OS === \"web\" ? \"searchbox\" : undefined}\n        aria-controls={Platform.OS === \"web\" ? listId : undefined}\n        aria-activedescendant={\n          Platform.OS === \"web\" ? activeDescendantId : undefined\n        }\n        id={Platform.OS === \"web\" ? inputId : undefined}\n        onChangeText={handleChangeText}\n        onFocus={handleFocus}\n        onBlur={handleBlur}\n        // @ts-expect-error - onKeyDown is web-only\n        onKeyDown={Platform.OS === \"web\" ? handleKeyDown : undefined}\n        style={[styles.input, style]}\n        {...props}\n      />\n    )\n  },\n)\n\nCommandInput.displayName = \"CommandInput\"\n\nexport type CommandListProps = ViewProps & {\n  scrollViewProps?: ScrollViewProps\n}\n\nexport const CommandList = React.forwardRef<View, CommandListProps>(\n  ({ children, style, scrollViewProps, ...props }, ref) => {\n    const { listId, activeValue, setActiveValue } = useCommand()\n\n    return (\n      <View\n        ref={ref}\n        // @ts-expect-error - web-only role\n        role={Platform.OS === \"web\" ? \"listbox\" : undefined}\n        id={Platform.OS === \"web\" ? listId : undefined}\n        style={[styles.list, style]}\n        {...props}\n      >\n        <ScrollView\n          keyboardShouldPersistTaps=\"handled\"\n          {...scrollViewProps}\n          contentContainerStyle={[\n            styles.listContent,\n            scrollViewProps?.contentContainerStyle,\n          ]}\n        >\n          <RovingFocusGroup.RovingFocusGroup\n            orientation=\"vertical\"\n            value={activeValue}\n            onValueChange={setActiveValue}\n            loop\n          >\n            {children}\n          </RovingFocusGroup.RovingFocusGroup>\n        </ScrollView>\n      </View>\n    )\n  },\n)\n\nCommandList.displayName = \"CommandList\"\n\nexport type CommandItemProps = Omit<PressableProps, \"children\"> & {\n  children?: React.ReactNode\n  value: string\n  textValue?: string\n  disabled?: boolean\n  onSelect?: (value: string) => void\n}\n\nfunction resolveTextValue(children: React.ReactNode, fallback?: string) {\n  if (typeof children === \"string\" || typeof children === \"number\") {\n    return String(children)\n  }\n  if (Array.isArray(children)) {\n    const text = children\n      .map((child) =>\n        typeof child === \"string\" || typeof child === \"number\"\n          ? String(child)\n          : \"\",\n      )\n      .join(\"\")\n    return text || fallback\n  }\n  return fallback\n}\n\nexport const CommandItem = React.forwardRef<View, CommandItemProps>(\n  (\n    { value, textValue, disabled, children, onSelect, onPress, style, ...props },\n    ref,\n  ) => {\n    const {\n      query,\n      shouldFilter,\n      filterItem,\n      registerItem,\n      activeValue,\n      setActiveValue,\n      getItemId,\n      setItemAction,\n    } = useCommand()\n    const isDisabled = !!disabled\n    const label = textValue ?? resolveTextValue(children, value) ?? value\n    const isActive = activeValue === value\n    const search = query.trim()\n    const isVisible =\n      !shouldFilter ||\n      !search ||\n      filterItem({ value, label, disabled: isDisabled, order: 0 }, search)\n    const itemId = Platform.OS === \"web\" ? getItemId(value) : undefined\n\n    const variantStyles = styles.useVariants({\n      active: isActive,\n      disabled: isDisabled,\n    })\n\n    React.useEffect(() => {\n      return registerItem(value, label, isDisabled)\n    }, [isDisabled, label, registerItem, value])\n\n    React.useEffect(() => {\n      if (!onSelect || isDisabled) {\n        setItemAction(value, undefined)\n        return () => setItemAction(value, undefined)\n      }\n\n      const handler = (selectedValue: string) => {\n        if (isDisabled) return\n        onSelect(selectedValue)\n      }\n      setItemAction(value, handler)\n      return () => setItemAction(value, undefined)\n    }, [isDisabled, onSelect, setItemAction, value])\n\n    const handlePress = React.useCallback(\n      (event: unknown) => {\n        if (isDisabled) return\n        onSelect?.(value)\n        // @ts-expect-error - React Native event type\n        onPress?.(event)\n      },\n      [isDisabled, onPress, onSelect, value],\n    )\n\n    const handleHoverIn = React.useCallback(() => {\n      if (isDisabled) return\n      setActiveValue(value)\n    }, [isDisabled, setActiveValue, value])\n\n    const handleFocus = React.useCallback(() => {\n      if (isDisabled) return\n      setActiveValue(value)\n    }, [isDisabled, setActiveValue, value])\n\n    const handleKeyDown = React.useCallback(\n      // biome-ignore lint/suspicious/noExplicitAny: Web-only keyboard event type\n      (event: any) => {\n        if (Platform.OS !== \"web\" || isDisabled) return\n        if (event.key === \"Enter\" || event.key === \" \") {\n          event.preventDefault()\n          handlePress(event)\n        }\n      },\n      [handlePress, isDisabled],\n    )\n\n    if (!isVisible) return null\n\n    return (\n      <RovingFocusGroup.RovingFocusItem value={value} disabled={isDisabled} asChild>\n        <Pressable\n          ref={ref}\n          role={Platform.OS === \"web\" ? \"option\" : undefined}\n          aria-disabled={Platform.OS === \"web\" ? isDisabled : undefined}\n          aria-selected={Platform.OS === \"web\" ? isActive : undefined}\n          id={itemId}\n          accessibilityRole=\"button\"\n          accessibilityState={{ disabled: isDisabled, selected: isActive }}\n          disabled={isDisabled}\n          onPress={handlePress}\n          onHoverIn={handleHoverIn}\n          onFocus={handleFocus}\n          // @ts-expect-error - onKeyDown is web-only\n          onKeyDown={Platform.OS === \"web\" ? handleKeyDown : undefined}\n          style={({ pressed }) =>\n            [\n              styles.item,\n              variantStyles,\n              pressed && !isDisabled && styles.itemPressed,\n              typeof style === \"function\" ? style({ pressed }) : style,\n              // biome-ignore lint/suspicious/noExplicitAny: Complex style array with variants requires type assertion\n            ] as any\n          }\n          {...props}\n        >\n          {typeof children === \"string\" || typeof children === \"number\" ? (\n            <Text style={styles.itemText}>{children}</Text>\n          ) : (\n            children\n          )}\n        </Pressable>\n      </RovingFocusGroup.RovingFocusItem>\n    )\n  },\n)\n\nCommandItem.displayName = \"CommandItem\"\n\nexport type CommandEmptyProps = TextProps & {\n  style?: StyleProp<TextStyle>\n}\n\nexport const CommandEmpty = React.forwardRef<Text, CommandEmptyProps>(\n  ({ style, children, ...props }, ref) => {\n    const { filteredItems } = useCommand()\n    if (filteredItems.length > 0) return null\n    return (\n      <Text ref={ref} style={[styles.empty, style]} {...props}>\n        {children}\n      </Text>\n    )\n  },\n)\n\nCommandEmpty.displayName = \"CommandEmpty\"\n\nexport type CommandGroupProps = ViewProps\n\nexport const CommandGroup = React.forwardRef<View, CommandGroupProps>(\n  ({ style, ...props }, ref) => {\n    return <View ref={ref} style={[styles.group, style]} {...props} />\n  },\n)\n\nCommandGroup.displayName = \"CommandGroup\"\n\nexport type CommandSeparatorProps = ViewProps & {\n  style?: StyleProp<ViewStyle>\n}\n\nexport const CommandSeparator = React.forwardRef<View, CommandSeparatorProps>(\n  ({ style, ...props }, ref) => {\n    return <View ref={ref} style={[styles.separator, style]} {...props} />\n  },\n)\n\nCommandSeparator.displayName = \"CommandSeparator\"\n\nexport type CommandShortcutProps = TextProps & {\n  style?: StyleProp<TextStyle>\n}\n\nexport const CommandShortcut = React.forwardRef<Text, CommandShortcutProps>(\n  ({ style, ...props }, ref) => {\n    return <Text ref={ref} style={[styles.shortcut, style]} {...props} />\n  },\n)\n\nCommandShortcut.displayName = \"CommandShortcut\"\n\nconst styles = StyleSheet.create((theme) => ({\n  container: {\n    backgroundColor: theme.colors.popover,\n    borderRadius: theme.radius.md,\n    borderWidth: 1,\n    borderColor: theme.colors.border,\n    overflow: \"hidden\",\n  },\n  input: {\n    height: theme.spacing[10],\n    width: \"100%\",\n    borderBottomWidth: 1,\n    borderBottomColor: theme.colors.border,\n    paddingHorizontal: theme.spacing[3],\n    fontSize: theme.typography.sizes.sm,\n    lineHeight: theme.typography.lineHeights.sm,\n    color: theme.colors.foreground,\n    variants: {\n      focused: {\n        true: {\n          borderBottomColor: theme.colors.ring,\n        },\n      },\n    },\n  },\n  list: {\n    maxHeight: 320,\n  },\n  listContent: {\n    paddingVertical: theme.spacing[2],\n  },\n  item: {\n    minHeight: theme.spacing[8],\n    paddingHorizontal: theme.spacing[3],\n    paddingVertical: theme.spacing[2],\n    borderRadius: theme.radius.sm,\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: theme.spacing[2],\n    variants: {\n      active: {\n        true: {\n          backgroundColor: theme.colors.muted,\n        },\n      },\n      disabled: {\n        true: {\n          opacity: 0.5,\n        },\n      },\n    },\n  },\n  itemPressed: {\n    backgroundColor: theme.colors.muted,\n  },\n  itemText: {\n    fontSize: theme.typography.sizes.sm,\n    lineHeight: theme.typography.lineHeights.sm,\n    color: theme.colors.popoverForeground,\n  },\n  empty: {\n    paddingHorizontal: theme.spacing[3],\n    paddingVertical: theme.spacing[3],\n    fontSize: theme.typography.sizes.sm,\n    color: theme.colors.mutedForeground,\n  },\n  group: {\n    paddingVertical: theme.spacing[1],\n  },\n  separator: {\n    height: 1,\n    backgroundColor: theme.colors.border,\n    marginVertical: theme.spacing[1],\n  },\n  shortcut: {\n    marginLeft: \"auto\",\n    fontSize: theme.typography.sizes.xs,\n    color: theme.colors.mutedForeground,\n  },\n}))\n",
      "type": "registry:ui"
    }
  ]
}
