{
  "name": "slider",
  "type": "registry:ui",
  "title": "Slider",
  "description": "A slider component for selecting values from a range with single/multi-thumb support, step values, full keyboard navigation on web, and theme-based styling.",
  "registryDependencies": [
    "@shadniwind/tokens",
    "@shadniwind/roving-focus"
  ],
  "files": [
    {
      "path": "components/ui/slider.tsx",
      "content": "import * as React from \"react\"\nimport {\n  Animated,\n  type GestureResponderEvent,\n  type PanResponderGestureState,\n  type LayoutChangeEvent,\n  PanResponder,\n  Platform,\n  type StyleProp,\n  View,\n  type ViewProps,\n  type ViewStyle,\n} from \"react-native\"\nimport { StyleSheet, useUnistyles } from \"react-native-unistyles\"\nimport * as RovingFocusGroup from \"../primitives/roving-focus/index\"\n\nexport type SliderValue = number | number[]\n\nexport interface SliderProps extends ViewProps {\n  value?: SliderValue\n  defaultValue?: SliderValue\n  min?: number\n  max?: number\n  step?: number\n  onValueChange?: (value: SliderValue) => void\n  onSlideEnd?: (value: SliderValue) => void\n  disabled?: boolean\n  size?: \"sm\" | \"md\" | \"lg\"\n  orientation?: \"horizontal\" | \"vertical\"\n  activeColor?: string\n  inactiveColor?: string\n  trackStyle?: StyleProp<ViewStyle>\n  thumbStyle?: StyleProp<ViewStyle>\n}\n\nconst TRACK_HEIGHTS = {\n  sm: 4,\n  md: 6,\n  lg: 8,\n} as const\n\nconst THUMB_SIZES = {\n  sm: 16,\n  md: 20,\n  lg: 24,\n} as const\n\ntype SliderRef = React.ComponentRef<typeof View>\n\nexport const Slider = React.forwardRef<SliderRef, SliderProps>(\n  (\n    {\n      value: valueProp,\n      defaultValue = 0,\n      min = 0,\n      max = 100,\n      step = 1,\n      onValueChange,\n      onSlideEnd,\n      disabled = false,\n      size = \"md\",\n      orientation = \"horizontal\",\n      activeColor,\n      inactiveColor,\n      trackStyle,\n      thumbStyle,\n      style,\n      ...props\n    },\n    ref,\n  ) => {\n    const isVertical = orientation === \"vertical\"\n    const { theme } = useUnistyles()\n\n    const resolvedActiveColor = activeColor ?? theme.colors.primary\n    const resolvedInactiveColor = inactiveColor ?? theme.colors.muted\n\n    const isMultiThumb = Array.isArray(defaultValue) || Array.isArray(valueProp)\n\n    const [uncontrolledValue, setUncontrolledValue] =\n      React.useState<SliderValue>(defaultValue)\n    const isControlled = valueProp !== undefined\n    const value = isControlled ? valueProp : uncontrolledValue\n\n    const values = React.useMemo(\n      () => (Array.isArray(value) ? [...value].sort((a, b) => a - b) : [value]),\n      [value],\n    )\n\n    const thumbSize = THUMB_SIZES[size]\n    const trackHeight = TRACK_HEIGHTS[size]\n    const trackInset = Math.max(0, (thumbSize - trackHeight) / 2)\n\n    const [trackLayout, setTrackLayout] = React.useState({\n      width: 0,\n      height: 0,\n    })\n\n    const [draggingIndex, setDraggingIndex] = React.useState<number | null>(\n      null,\n    )\n\n    const lastDraggedValue = React.useRef<number | null>(null)\n\n    const thumbPositions = React.useRef<Animated.Value[]>(\n      values.map((v) => new Animated.Value(v)),\n    )\n    const thumbIdCounter = React.useRef(0)\n    const thumbIds = React.useRef<string[]>(\n      values.map(() => `thumb-${thumbIdCounter.current++}`),\n    )\n\n    if (thumbPositions.current.length > values.length) {\n      thumbPositions.current = thumbPositions.current.slice(0, values.length)\n    }\n    if (thumbIds.current.length > values.length) {\n      thumbIds.current = thumbIds.current.slice(0, values.length)\n    }\n    while (thumbPositions.current.length < values.length) {\n      thumbPositions.current.push(\n        new Animated.Value(values[thumbPositions.current.length]),\n      )\n    }\n    while (thumbIds.current.length < values.length) {\n      thumbIds.current.push(`thumb-${thumbIdCounter.current++}`)\n    }\n\n    React.useEffect(() => {\n      thumbPositions.current.forEach((pos, i) => {\n        Animated.spring(pos, {\n          toValue: values[i],\n          useNativeDriver: false,\n          damping: 20,\n          stiffness: 300,\n        }).start()\n      })\n    }, [values])\n\n    const handleTrackLayout = React.useCallback((event: LayoutChangeEvent) => {\n      setTrackLayout({\n        width: event.nativeEvent.layout.width,\n        height: event.nativeEvent.layout.height,\n      })\n    }, [])\n\n    const getNormalizedPosition = React.useCallback(\n      (relativeX: number, relativeY: number) => {\n        const trackLength = isVertical ? trackLayout.height : trackLayout.width\n        if (trackLength <= 0) return 0\n\n        const pos = isVertical ? relativeY : relativeX\n        const clamped = Math.max(0, Math.min(pos, trackLength))\n        return clamped / trackLength\n      },\n      [trackLayout.height, trackLayout.width, isVertical],\n    )\n\n    const getValueFromNormalized = React.useCallback(\n      (normalized: number) => {\n        const raw = min + normalized * (max - min)\n        const stepped = step > 0 ? Math.round(raw / step) * step : raw\n        return Math.min(Math.max(stepped, min), max) as number\n      },\n      [min, max, step],\n    )\n\n    const handlePanResponderStart = React.useCallback(\n      (\n        event: GestureResponderEvent,\n        _gestureState: PanResponderGestureState,\n      ) => {\n        const trackLength = isVertical ? trackLayout.height : trackLayout.width\n        if (disabled || trackLength <= 0) return\n\n        const relativeX = event.nativeEvent.locationX\n        const relativeY = event.nativeEvent.locationY\n\n        const normalized = getNormalizedPosition(relativeX, relativeY)\n        const newValue = getValueFromNormalized(normalized)\n\n        let nearestIndex = 0\n        let nearestDistance = Infinity\n\n        values.forEach((v, i) => {\n          const distance = Math.abs(v - newValue)\n          if (distance < nearestDistance) {\n            nearestDistance = distance\n            nearestIndex = i\n          }\n        })\n\n        setDraggingIndex(nearestIndex)\n        setFocusedIndex(nearestIndex)\n      },\n      [\n        disabled,\n        trackLayout.height,\n        trackLayout.width,\n        isVertical,\n        getNormalizedPosition,\n        getValueFromNormalized,\n        values,\n      ],\n    )\n\n    const handlePanResponderMove = React.useCallback(\n      (\n        event: GestureResponderEvent,\n        _gestureState: PanResponderGestureState,\n      ) => {\n        const trackLength = isVertical ? trackLayout.height : trackLayout.width\n        if (disabled || draggingIndex === null || trackLength <= 0) return\n\n        const relativeX = event.nativeEvent.locationX\n        const relativeY = event.nativeEvent.locationY\n\n        const normalized = getNormalizedPosition(relativeX, relativeY)\n        let newValue = getValueFromNormalized(normalized)\n\n        const sortedValues = [...values].sort((a, b) => a - b)\n\n        if (draggingIndex > 0) {\n          newValue = Math.max(newValue, sortedValues[draggingIndex - 1] + step)\n        }\n        if (draggingIndex < values.length - 1) {\n          newValue = Math.min(newValue, sortedValues[draggingIndex + 1] - step)\n        }\n\n        const newValues = [...values]\n        newValues[draggingIndex] = newValue\n        lastDraggedValue.current = newValue\n\n        const emittedValue = isMultiThumb ? newValues : newValues[0]\n\n        if (!isControlled) {\n          setUncontrolledValue(emittedValue)\n        }\n        onValueChange?.(emittedValue)\n      },\n      [\n        disabled,\n        draggingIndex,\n        trackLayout.height,\n        trackLayout.width,\n        isVertical,\n        values,\n        step,\n        isControlled,\n        isMultiThumb,\n        onValueChange,\n        getNormalizedPosition,\n        getValueFromNormalized,\n      ],\n    )\n\n    const handlePanResponderEnd = React.useCallback(() => {\n      if (draggingIndex !== null) {\n        const currentValue =\n          lastDraggedValue.current ?? values[draggingIndex] ?? min\n        const emittedValue = isMultiThumb\n          ? [\n              ...values.slice(0, draggingIndex),\n              currentValue,\n              ...values.slice(draggingIndex + 1),\n            ]\n          : currentValue\n        onSlideEnd?.(emittedValue)\n        lastDraggedValue.current = null\n        setDraggingIndex(null)\n      }\n    }, [draggingIndex, values, isMultiThumb, min, onSlideEnd])\n\n    const panResponder = PanResponder.create({\n      onStartShouldSetPanResponder: () => !disabled,\n      onMoveShouldSetPanResponder: () => !disabled,\n      onPanResponderGrant: handlePanResponderStart,\n      onPanResponderMove: handlePanResponderMove,\n      onPanResponderRelease: handlePanResponderEnd,\n      onPanResponderTerminate: handlePanResponderEnd,\n    })\n\n    const [focusedIndex, setFocusedIndex] = React.useState<number>(0)\n\n    const handleFocusValueChange = React.useCallback((newValue: string) => {\n      setFocusedIndex(Number(newValue))\n    }, [])\n\n    const handleKeyDown = React.useCallback(\n      (event: React.KeyboardEvent) => {\n        if (Platform.OS !== \"web\" || disabled) return\n        if (event.key === \"Tab\") {\n          return\n        }\n\n        const isIncrementKey =\n          event.key === \"ArrowRight\" || event.key === \"ArrowUp\"\n        const isDecrementKey =\n          event.key === \"ArrowLeft\" || event.key === \"ArrowDown\"\n        const isHomeKey = event.key === \"Home\"\n        const isEndKey = event.key === \"End\"\n\n        if (!isIncrementKey && !isDecrementKey && !isHomeKey && !isEndKey) {\n          return\n        }\n\n        const range = max - min\n        if (range === 0) {\n          event.preventDefault()\n          return\n        }\n\n        const sortedValues = [...values].sort((a, b) => a - b)\n        const currentValue = values[focusedIndex] ?? min\n        const stepValue = step / range\n        let newNormalized = (currentValue - min) / range\n\n        if (isIncrementKey) {\n          newNormalized = Math.min(1, newNormalized + stepValue)\n        } else if (isDecrementKey) {\n          newNormalized = Math.max(0, newNormalized - stepValue)\n        } else if (isHomeKey) {\n          newNormalized = 0\n        } else if (isEndKey) {\n          newNormalized = 1\n        }\n\n        event.preventDefault()\n        let newValue = getValueFromNormalized(newNormalized)\n\n        if (values.length > 1) {\n          if (focusedIndex > 0) {\n            newValue = Math.max(newValue, sortedValues[focusedIndex - 1] + step)\n          }\n          if (focusedIndex < values.length - 1) {\n            newValue = Math.min(newValue, sortedValues[focusedIndex + 1] - step)\n          }\n        }\n\n        const newValues = [...values]\n        newValues[focusedIndex] = newValue\n        lastDraggedValue.current = newValue\n\n        const emittedValue = isMultiThumb ? newValues : newValues[0]\n\n        if (!isControlled) {\n          setUncontrolledValue(emittedValue)\n        }\n        onValueChange?.(emittedValue)\n        onSlideEnd?.(emittedValue)\n      },\n      [\n        disabled,\n        focusedIndex,\n        values,\n        step,\n        max,\n        min,\n        isControlled,\n        isMultiThumb,\n        onValueChange,\n        onSlideEnd,\n        getValueFromNormalized,\n      ],\n    )\n\n    const thumbCount = values.length\n\n    const animatedThumbPositions = React.useMemo(() => {\n      return thumbPositions.current.slice(0, thumbCount).map((pos) =>\n        pos.interpolate({\n          inputRange: [min, max],\n          outputRange: [0, isVertical ? trackLayout.height : trackLayout.width],\n          extrapolate: \"clamp\",\n        }),\n      )\n    }, [\n      min,\n      max,\n      isVertical,\n      trackLayout.height,\n      trackLayout.width,\n      thumbCount,\n    ])\n\n    const renderTrackFills = () => {\n      if (values.length === 0) return null\n\n      const trackLength = isVertical ? trackLayout.height : trackLayout.width\n      if (trackLength <= 0) return null\n\n      const trackFillInsetStyle = isVertical\n        ? { left: trackInset }\n        : { top: trackInset }\n      const sortedValues = [...values].sort((a, b) => a - b)\n      const fills: React.ReactNode[] = []\n\n      const firstValue = sortedValues[0]\n      const lastValue = sortedValues[sortedValues.length - 1]\n\n      if (values.length === 1) {\n        const normalized = (firstValue - min) / (max - min)\n        const length = normalized * trackLength\n\n        fills.push(\n          <Animated.View\n            key={`fill-active-${firstValue}`}\n            style={[\n              styles.trackFill,\n              {\n                backgroundColor: resolvedActiveColor,\n              },\n              trackFillInsetStyle,\n              isVertical\n                ? { height: length, width: trackHeight }\n                : { width: length, height: trackHeight },\n              trackStyle,\n            ]}\n          />,\n        )\n      } else {\n        const startNormalized = (firstValue - min) / (max - min)\n        const endNormalized = (lastValue - min) / (max - min)\n        const startOffset = startNormalized * trackLength\n        const activeLength = (endNormalized - startNormalized) * trackLength\n\n        fills.push(\n          <Animated.View\n            key={`fill-active-${firstValue}-${lastValue}`}\n            style={[\n              styles.trackFill,\n              {\n                backgroundColor: resolvedActiveColor,\n              },\n              trackFillInsetStyle,\n              isVertical\n                ? {\n                    height: activeLength,\n                    width: trackHeight,\n                    top: startOffset,\n                  }\n                : {\n                    width: activeLength,\n                    height: trackHeight,\n                    left: startOffset,\n                  },\n              trackStyle,\n            ]}\n          />,\n        )\n      }\n\n      return fills\n    }\n\n    const renderThumbs = () => {\n      return values.map((val, index) => {\n        const isFocused = focusedIndex === index\n\n        const thumbValue = val\n        const thumbKey = thumbIds.current[index]\n\n        const thumbContent = (\n          <Animated.View\n            style={[\n              styles.thumb,\n              {\n                width: thumbSize,\n                height: thumbSize,\n                backgroundColor: resolvedActiveColor,\n              },\n              isFocused && styles.thumbFocused,\n              isVertical\n                ? { transform: [{ translateY: animatedThumbPositions[index] }] }\n                : {\n                    transform: [{ translateX: animatedThumbPositions[index] }],\n                  },\n              thumbStyle,\n            ]}\n          />\n        )\n\n        if (Platform.OS === \"web\") {\n          return (\n            <RovingFocusGroup.RovingFocusItem\n              key={thumbKey}\n              value={String(index)}\n              disabled={disabled}\n              asChild\n            >\n              <View\n                style={styles.thumbWrapper}\n                tabIndex={0}\n                // @ts-expect-error - web-only prop\n                onKeyDown={handleKeyDown}\n                role=\"slider\"\n                aria-valuemin={min}\n                aria-valuemax={max}\n                aria-valuenow={thumbValue}\n                aria-orientation={orientation}\n                aria-disabled={disabled}\n              >\n                {thumbContent}\n              </View>\n            </RovingFocusGroup.RovingFocusItem>\n          )\n        }\n\n        return (\n          <React.Fragment key={thumbKey}>\n            {thumbContent}\n          </React.Fragment>\n        )\n      })\n    }\n\n    const renderContent = () => (\n      <View\n        style={[styles.trackContainer, isVertical && styles.vertical]}\n        {...panResponder.panHandlers}\n      >\n        <View\n          style={[\n            styles.trackWrapper,\n            isVertical && styles.verticalWrapper,\n            isVertical ? { minWidth: thumbSize } : { minHeight: thumbSize },\n          ]}\n          onLayout={handleTrackLayout}\n        >\n          <View\n            style={[\n              styles.track,\n              isVertical ? styles.trackVertical : styles.trackHorizontal,\n              isVertical ? { width: trackHeight } : { height: trackHeight },\n              {\n                backgroundColor: resolvedInactiveColor,\n              },\n              trackStyle,\n            ]}\n          />\n          {renderTrackFills()}\n          {renderThumbs()}\n        </View>\n      </View>\n    )\n\n    const sliderValue = values[focusedIndex] ?? min\n\n    return (\n      <View ref={ref} style={[disabled && styles.disabled, style]} {...props}>\n        {Platform.OS === \"web\" ? (\n          <RovingFocusGroup.RovingFocusGroup\n            orientation={isVertical ? \"vertical\" : \"horizontal\"}\n            loop\n            value={String(focusedIndex)}\n            onValueChange={handleFocusValueChange}\n            asChild\n          >\n            <View style={styles.webSliderContainer} tabIndex={-1}>\n              {renderContent()}\n            </View>\n          </RovingFocusGroup.RovingFocusGroup>\n        ) : (\n          <View\n            accessibilityRole=\"adjustable\"\n            accessibilityValue={{ min, max, now: sliderValue }}\n            accessibilityState={{ disabled }}\n          >\n            {renderContent()}\n          </View>\n        )}\n      </View>\n    )\n  },\n)\n\nSlider.displayName = \"Slider\"\n\nconst styles = StyleSheet.create((theme) => ({\n  webSliderContainer: {\n    outlineWidth: 0,\n  },\n  trackContainer: {\n    position: \"relative\",\n    justifyContent: \"center\",\n  },\n  trackWrapper: {\n    position: \"relative\",\n    justifyContent: \"center\",\n    alignItems: \"center\",\n  },\n  verticalWrapper: {\n    flex: 1,\n    flexDirection: \"column\",\n    alignItems: \"center\",\n    minHeight: 20,\n  },\n  track: {\n    borderRadius: 999,\n    overflow: \"hidden\",\n  },\n  trackHorizontal: {\n    width: \"100%\",\n    height: 4,\n  },\n  trackVertical: {\n    width: 4,\n    flex: 1,\n  },\n  trackFill: {\n    position: \"absolute\",\n    borderRadius: 999,\n    left: 0,\n    top: 0,\n  },\n  thumb: {\n    position: \"absolute\",\n    borderRadius: 999,\n    shadowColor: \"#000\",\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.15,\n    shadowRadius: 2,\n    elevation: 3,\n  },\n  thumbWrapper: {\n    outlineWidth: 0,\n  },\n  thumbFocused: {\n    outlineWidth: 2,\n    outlineStyle: \"solid\",\n    outlineColor: theme.colors.ring,\n  },\n  vertical: {\n    flexDirection: \"column\",\n  },\n  disabled: {\n    opacity: 0.5,\n  },\n}))\n",
      "type": "registry:ui"
    }
  ]
}
