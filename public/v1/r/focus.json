{
  "name": "focus",
  "type": "registry:lib",
  "title": "Focus",
  "description": "Focus primitive for trapping and restoring focus.",
  "files": [
    {
      "path": "lib/focus/types.ts",
      "content": "import type { ViewProps } from \"react-native\"\n\nexport interface FocusScopeProps extends ViewProps {\n  /**\n   * Whether to loop focus when reaching the end of the scope.\n   * @default false\n   */\n  loop?: boolean\n\n  /**\n   * Whether to trap focus within the scope.\n   * @default false\n   */\n  trapped?: boolean\n\n  /**\n   * Event handler called when auto-focusing on mount.\n   * Can be prevented.\n   */\n  onMountAutoFocus?: (event: Event) => void\n\n  /**\n   * Event handler called when auto-focusing on unmount.\n   * Can be prevented.\n   */\n  onUnmountAutoFocus?: (event: Event) => void\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "lib/focus/focus-scope.tsx",
      "content": "import { Platform } from \"react-native\"\n\nimport { FocusScope as FocusScopeNative } from \"./focus-scope.native.js\"\nimport { FocusScope as FocusScopeWeb } from \"./focus-scope.web.js\"\n\nexport const FocusScope =\n  Platform.OS === \"web\" ? FocusScopeWeb : FocusScopeNative\n",
      "type": "registry:lib"
    },
    {
      "path": "lib/focus/focus-scope.web.tsx",
      "content": "import * as React from \"react\"\nimport { View } from \"react-native\"\nimport type { FocusScopeProps } from \"./types.js\"\n\nconst AUTOFOCUS_ON_MOUNT = \"focusScope.autoFocusOnMount\"\nconst AUTOFOCUS_ON_UNMOUNT = \"focusScope.autoFocusOnUnmount\"\n\nconst FOCUSABLE_SELECTOR =\n  'a[href], button:not([disabled]), input:not([hidden]):not([type=\"hidden\"]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex=\"-1\"])'\n\nfunction getFocusableElements(container: HTMLElement): HTMLElement[] {\n  const elements = Array.from(\n    container.querySelectorAll(FOCUSABLE_SELECTOR),\n  ) as HTMLElement[]\n  return elements.filter((el) => el.offsetParent !== null)\n}\n\nexport const FocusScope = React.forwardRef<View, FocusScopeProps>(\n  (\n    {\n      loop = false,\n      trapped = false,\n      onMountAutoFocus,\n      onUnmountAutoFocus,\n      ...props\n    },\n    ref,\n  ) => {\n    const containerRef = React.useRef<HTMLElement | null>(null)\n    const lastFocusedElementRef = React.useRef<HTMLElement | null>(null)\n\n    const setRef = React.useCallback(\n      (node: View | null) => {\n        containerRef.current = node as unknown as HTMLElement\n        if (typeof ref === \"function\") {\n          ref(node)\n        } else if (ref) {\n          ;(ref as { current: View | null }).current = node\n        }\n      },\n      [ref],\n    )\n\n    // Record the previously focused element when trapping activates\n    React.useEffect(() => {\n      if (trapped) {\n        lastFocusedElementRef.current = document.activeElement as HTMLElement\n      }\n    }, [trapped])\n\n    // Mount Auto Focus\n    React.useEffect(() => {\n      if (!trapped) return\n\n      const container = containerRef.current\n      if (!container) return\n\n      // Use a strict-ish Event equivalent for Web\n      const evt = new Event(AUTOFOCUS_ON_MOUNT, { cancelable: true })\n      onMountAutoFocus?.(evt)\n\n      if (!evt.defaultPrevented) {\n        const elements = getFocusableElements(container)\n        if (elements.length > 0) {\n          elements[0].focus()\n        }\n      }\n    }, [trapped, onMountAutoFocus])\n\n    // Unmount Auto Focus (Restore)\n    React.useEffect(() => {\n      return () => {\n        if (!trapped) return\n\n        const evt = new Event(AUTOFOCUS_ON_UNMOUNT, { cancelable: true })\n        onUnmountAutoFocus?.(evt)\n\n        if (!evt.defaultPrevented) {\n          lastFocusedElementRef.current?.focus()\n        }\n      }\n    }, [trapped, onUnmountAutoFocus])\n\n    // Trap logic (keydown)\n    React.useEffect(() => {\n      if (!trapped) return\n\n      const handleKeyDown = (e: KeyboardEvent) => {\n        if (e.key !== \"Tab\") return\n\n        const container = containerRef.current\n        if (!container) return\n\n        const elements = getFocusableElements(container)\n        if (elements.length === 0) {\n          e.preventDefault()\n          return\n        }\n\n        const first = elements[0]\n        const last = elements[elements.length - 1]\n        const active = document.activeElement as HTMLElement\n\n        if (e.shiftKey) {\n          if (active === first) {\n            e.preventDefault()\n            if (loop) last.focus()\n          }\n        } else {\n          if (active === last) {\n            e.preventDefault()\n            if (loop) first.focus()\n          }\n        }\n      }\n\n      document.addEventListener(\"keydown\", handleKeyDown)\n      return () => document.removeEventListener(\"keydown\", handleKeyDown)\n    }, [trapped, loop])\n\n    return <View ref={setRef} {...props} />\n  },\n)\n\nFocusScope.displayName = \"FocusScope\"\n",
      "type": "registry:lib"
    },
    {
      "path": "lib/focus/focus-scope.native.tsx",
      "content": "import * as React from \"react\"\nimport { View } from \"react-native\"\nimport type { FocusScopeProps } from \"./types.js\"\n\nexport const FocusScope = React.forwardRef<View, FocusScopeProps>(\n  ({ loop, trapped, onMountAutoFocus, onUnmountAutoFocus, ...props }, ref) => {\n    return <View ref={ref} {...props} />\n  },\n)\n\nFocusScope.displayName = \"FocusScope\"\n",
      "type": "registry:lib"
    },
    {
      "path": "lib/focus/index.ts",
      "content": "export * from \"./focus-scope.js\"\nexport * from \"./types.js\"\n",
      "type": "registry:lib"
    }
  ]
}
