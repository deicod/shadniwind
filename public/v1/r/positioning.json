{
  "name": "positioning",
  "type": "registry:lib",
  "title": "Positioning",
  "description": "Positioning primitive for floating content with anchor measurement, placement, and collision handling.",
  "files": [
    {
      "path": "lib/positioning/types.ts",
      "content": "import type { RefObject } from \"react\"\nimport type { View } from \"react-native\"\n\n/**\n * Placement options for positioned content relative to an anchor.\n */\nexport type Placement =\n  | \"top\"\n  | \"top-start\"\n  | \"top-end\"\n  | \"bottom\"\n  | \"bottom-start\"\n  | \"bottom-end\"\n  | \"left\"\n  | \"left-start\"\n  | \"left-end\"\n  | \"right\"\n  | \"right-start\"\n  | \"right-end\"\n\n/**\n * The side of the anchor where content should be placed.\n */\nexport type Side = \"top\" | \"bottom\" | \"left\" | \"right\"\n\n/**\n * Alignment along the placement axis.\n */\nexport type Alignment = \"start\" | \"center\" | \"end\"\n\n/**\n * Measured rectangle coordinates (in screen/window space).\n */\nexport type Rect = {\n  x: number\n  y: number\n  width: number\n  height: number\n}\n\n/**\n * Computed position for the floating content.\n */\nexport type Position = {\n  top: number\n  left: number\n}\n\n/**\n * Result returned by the positioning hook.\n */\nexport type PositioningResult = {\n  /** Current computed position (top/left) */\n  position: Position\n  /** The final placement after collision handling (may differ from requested) */\n  actualPlacement: Placement\n  /** Whether measurement is complete and position is valid */\n  isPositioned: boolean\n  /** Trigger a re-measurement */\n  update: () => void\n}\n\n/**\n * Options for the usePositioning hook.\n */\nexport type UsePositioningOptions = {\n  /** Ref to the anchor/trigger element */\n  anchorRef: RefObject<View | null>\n  /** Ref to the floating content element */\n  contentRef: RefObject<View | null>\n  /** Desired placement of content relative to anchor */\n  placement?: Placement\n  /** Offset from the anchor (in pixels) */\n  offset?: number\n  /** Side offset for alignment (in pixels) */\n  alignOffset?: number\n  /** Whether to flip to opposite side on collision */\n  flip?: boolean\n  /** Padding from viewport edges for collision detection */\n  collisionPadding?: number\n  /** Whether positioning is currently active/open */\n  open?: boolean\n}\n\n/**\n * Viewport dimensions for collision detection.\n */\nexport type Viewport = {\n  width: number\n  height: number\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "lib/positioning/positioning-utils.ts",
      "content": "import type {\n  Alignment,\n  Placement,\n  Position,\n  Rect,\n  Side,\n  Viewport,\n} from \"./types\"\n\n/**\n * Parse a placement string into side and alignment components.\n */\nexport function parsePlacement(placement: Placement): {\n  side: Side\n  alignment: Alignment\n} {\n  const [side, alignment = \"center\"] = placement.split(\"-\") as [\n    Side,\n    Alignment | undefined,\n  ]\n  return { side, alignment: alignment ?? \"center\" }\n}\n\n/**\n * Get the opposite side for flip behavior.\n */\nexport function getOppositeSide(side: Side): Side {\n  const opposites: Record<Side, Side> = {\n    top: \"bottom\",\n    bottom: \"top\",\n    left: \"right\",\n    right: \"left\",\n  }\n  return opposites[side]\n}\n\n/**\n * Compose a placement from side and alignment.\n */\nexport function composePlacement(side: Side, alignment: Alignment): Placement {\n  if (alignment === \"center\") {\n    return side\n  }\n  return `${side}-${alignment}` as Placement\n}\n\n/**\n * Compute the position for floating content given anchor rect, content rect,\n * placement, and offsets.\n */\nexport function computePosition(\n  anchorRect: Rect,\n  contentRect: Rect,\n  placement: Placement,\n  offset: number,\n  alignOffset: number,\n): Position {\n  const { side, alignment } = parsePlacement(placement)\n\n  let top = 0\n  let left = 0\n\n  // Compute main axis position (side)\n  switch (side) {\n    case \"top\":\n      top = anchorRect.y - contentRect.height - offset\n      break\n    case \"bottom\":\n      top = anchorRect.y + anchorRect.height + offset\n      break\n    case \"left\":\n      left = anchorRect.x - contentRect.width - offset\n      break\n    case \"right\":\n      left = anchorRect.x + anchorRect.width + offset\n      break\n  }\n\n  // Compute cross axis position (alignment)\n  if (side === \"top\" || side === \"bottom\") {\n    // Horizontal alignment\n    switch (alignment) {\n      case \"start\":\n        left = anchorRect.x + alignOffset\n        break\n      case \"center\":\n        left = anchorRect.x + (anchorRect.width - contentRect.width) / 2\n        break\n      case \"end\":\n        left = anchorRect.x + anchorRect.width - contentRect.width - alignOffset\n        break\n    }\n  } else {\n    // Vertical alignment (side is left or right)\n    switch (alignment) {\n      case \"start\":\n        top = anchorRect.y + alignOffset\n        break\n      case \"center\":\n        top = anchorRect.y + (anchorRect.height - contentRect.height) / 2\n        break\n      case \"end\":\n        top =\n          anchorRect.y + anchorRect.height - contentRect.height - alignOffset\n        break\n    }\n  }\n\n  return { top, left }\n}\n\n/**\n * Check if a positioned rect overflows the viewport.\n */\nexport function detectOverflow(\n  position: Position,\n  contentRect: Rect,\n  viewport: Viewport,\n  padding: number,\n): { top: boolean; bottom: boolean; left: boolean; right: boolean } {\n  return {\n    top: position.top < padding,\n    bottom: position.top + contentRect.height > viewport.height - padding,\n    left: position.left < padding,\n    right: position.left + contentRect.width > viewport.width - padding,\n  }\n}\n\n/**\n * Apply flip middleware: if content overflows on the main axis side,\n * flip to the opposite side.\n */\nexport function applyFlip(\n  anchorRect: Rect,\n  contentRect: Rect,\n  placement: Placement,\n  offset: number,\n  alignOffset: number,\n  viewport: Viewport,\n  padding: number,\n): { position: Position; placement: Placement; flipped: boolean } {\n  const position = computePosition(\n    anchorRect,\n    contentRect,\n    placement,\n    offset,\n    alignOffset,\n  )\n  const overflow = detectOverflow(position, contentRect, viewport, padding)\n\n  const { side, alignment } = parsePlacement(placement)\n\n  // Check if main axis overflows\n  let shouldFlip = false\n  if (side === \"top\" && overflow.top) shouldFlip = true\n  if (side === \"bottom\" && overflow.bottom) shouldFlip = true\n  if (side === \"left\" && overflow.left) shouldFlip = true\n  if (side === \"right\" && overflow.right) shouldFlip = true\n\n  if (!shouldFlip) {\n    return { position, placement, flipped: false }\n  }\n\n  // Try flipped placement\n  const flippedSide = getOppositeSide(side)\n  const flippedPlacement = composePlacement(flippedSide, alignment)\n  const flippedPosition = computePosition(\n    anchorRect,\n    contentRect,\n    flippedPlacement,\n    offset,\n    alignOffset,\n  )\n  const flippedOverflow = detectOverflow(\n    flippedPosition,\n    contentRect,\n    viewport,\n    padding,\n  )\n\n  // Check if flipped position is better (doesn't overflow on main axis)\n  let useFlipped = false\n  if (flippedSide === \"top\" && !flippedOverflow.top) useFlipped = true\n  if (flippedSide === \"bottom\" && !flippedOverflow.bottom) useFlipped = true\n  if (flippedSide === \"left\" && !flippedOverflow.left) useFlipped = true\n  if (flippedSide === \"right\" && !flippedOverflow.right) useFlipped = true\n\n  if (useFlipped) {\n    return {\n      position: flippedPosition,\n      placement: flippedPlacement,\n      flipped: true,\n    }\n  }\n\n  // Flipped is not better, keep original\n  return { position, placement, flipped: false }\n}\n\n/**\n * Constrain position to viewport bounds as a fallback.\n */\nexport function constrainToViewport(\n  position: Position,\n  contentRect: Rect,\n  viewport: Viewport,\n  padding: number,\n): Position {\n  return {\n    top: Math.max(\n      padding,\n      Math.min(position.top, viewport.height - contentRect.height - padding),\n    ),\n    left: Math.max(\n      padding,\n      Math.min(position.left, viewport.width - contentRect.width - padding),\n    ),\n  }\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "lib/positioning/use-positioning.ts",
      "content": "import { Platform } from \"react-native\"\n\nimport { usePositioning as usePositioningNative } from \"./use-positioning.native\"\nimport { usePositioning as usePositioningWeb } from \"./use-positioning.web\"\n\n// Runtime platform selection keeps NodeNext extension requirements while preserving platform behavior.\nexport const usePositioning =\n  Platform.OS === \"web\" ? usePositioningWeb : usePositioningNative\n",
      "type": "registry:lib"
    },
    {
      "path": "lib/positioning/use-positioning.native.ts",
      "content": "import { useCallback, useEffect, useRef, useState } from \"react\"\nimport { Dimensions } from \"react-native\"\n\nimport {\n  applyFlip,\n  computePosition,\n  constrainToViewport,\n} from \"./positioning-utils\"\nimport type {\n  Placement,\n  Position,\n  PositioningResult,\n  Rect,\n  UsePositioningOptions,\n  Viewport,\n} from \"./types\"\n\n/**\n * Hook for positioning floating content relative to an anchor element.\n * Native implementation using measureInWindow.\n */\nexport function usePositioning(\n  options: UsePositioningOptions,\n): PositioningResult {\n  const {\n    anchorRef,\n    contentRef,\n    placement: requestedPlacement = \"bottom\",\n    offset = 8,\n    alignOffset = 0,\n    flip = true,\n    collisionPadding = 8,\n    open = true,\n  } = options\n\n  const [position, setPosition] = useState<Position>({ top: 0, left: 0 })\n  const [actualPlacement, setActualPlacement] =\n    useState<Placement>(requestedPlacement)\n  const [isPositioned, setIsPositioned] = useState(false)\n\n  // Track mount state to prevent updates after unmount\n  const isMountedRef = useRef(true)\n\n  useEffect(() => {\n    isMountedRef.current = true\n    return () => {\n      isMountedRef.current = false\n    }\n  }, [])\n\n  const measure = useCallback(() => {\n    if (!open) {\n      setIsPositioned(false)\n      return\n    }\n\n    const anchor = anchorRef.current\n    const content = contentRef.current\n\n    if (!anchor || !content) {\n      return\n    }\n\n    // Measure anchor position in window coordinates\n    anchor.measureInWindow((anchorX, anchorY, anchorWidth, anchorHeight) => {\n      if (!isMountedRef.current) return\n\n      // Handle measurement failure (returns 0s or undefined on collapsed views)\n      if (anchorWidth === 0 && anchorHeight === 0) {\n        return\n      }\n\n      // Measure content dimensions\n      content.measureInWindow(\n        (_contentX, _contentY, contentWidth, contentHeight) => {\n          if (!isMountedRef.current) return\n\n          // Content might not be fully laid out yet\n          if (contentWidth === 0 && contentHeight === 0) {\n            return\n          }\n\n          const anchorRect: Rect = {\n            x: anchorX,\n            y: anchorY,\n            width: anchorWidth,\n            height: anchorHeight,\n          }\n\n          const contentRect: Rect = {\n            x: 0,\n            y: 0,\n            width: contentWidth,\n            height: contentHeight,\n          }\n\n          // Get viewport dimensions\n          const { width: viewportWidth, height: viewportHeight } =\n            Dimensions.get(\"window\")\n          const viewport: Viewport = {\n            width: viewportWidth,\n            height: viewportHeight,\n          }\n\n          let computedPosition: Position\n          let finalPlacement: Placement\n\n          if (flip) {\n            const result = applyFlip(\n              anchorRect,\n              contentRect,\n              requestedPlacement,\n              offset,\n              alignOffset,\n              viewport,\n              collisionPadding,\n            )\n            computedPosition = result.position\n            finalPlacement = result.placement\n          } else {\n            computedPosition = computePosition(\n              anchorRect,\n              contentRect,\n              requestedPlacement,\n              offset,\n              alignOffset,\n            )\n            finalPlacement = requestedPlacement\n          }\n\n          // Constrain to viewport as final fallback\n          computedPosition = constrainToViewport(\n            computedPosition,\n            contentRect,\n            viewport,\n            collisionPadding,\n          )\n\n          setPosition(computedPosition)\n          setActualPlacement(finalPlacement)\n          setIsPositioned(true)\n        },\n      )\n    })\n  }, [\n    open,\n    anchorRef,\n    contentRef,\n    requestedPlacement,\n    offset,\n    alignOffset,\n    flip,\n    collisionPadding,\n  ])\n\n  // Measure when open state changes\n  useEffect(() => {\n    if (open) {\n      // Use requestAnimationFrame to ensure layout is complete\n      const rafId = requestAnimationFrame(() => {\n        measure()\n      })\n      return () => cancelAnimationFrame(rafId)\n    }\n    setIsPositioned(false)\n  }, [open, measure])\n\n  // Re-measure on dimension changes\n  useEffect(() => {\n    const subscription = Dimensions.addEventListener(\"change\", () => {\n      if (open) {\n        measure()\n      }\n    })\n\n    return () => subscription.remove()\n  }, [open, measure])\n\n  return {\n    position,\n    actualPlacement,\n    isPositioned,\n    update: measure,\n  }\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "lib/positioning/use-positioning.web.ts",
      "content": "import { useCallback, useEffect, useRef, useState } from \"react\"\n\nimport {\n  applyFlip,\n  computePosition,\n  constrainToViewport,\n} from \"./positioning-utils\"\nimport type {\n  Placement,\n  Position,\n  PositioningResult,\n  Rect,\n  UsePositioningOptions,\n  Viewport,\n} from \"./types\"\n\n/**\n * Hook for positioning floating content relative to an anchor element.\n * Web implementation using getBoundingClientRect.\n */\nexport function usePositioning(\n  options: UsePositioningOptions,\n): PositioningResult {\n  const {\n    anchorRef,\n    contentRef,\n    placement: requestedPlacement = \"bottom\",\n    offset = 8,\n    alignOffset = 0,\n    flip = true,\n    collisionPadding = 8,\n    open = true,\n  } = options\n\n  const [position, setPosition] = useState<Position>({ top: 0, left: 0 })\n  const [actualPlacement, setActualPlacement] =\n    useState<Placement>(requestedPlacement)\n  const [isPositioned, setIsPositioned] = useState(false)\n\n  // Track mount state to prevent updates after unmount\n  const isMountedRef = useRef(true)\n\n  useEffect(() => {\n    isMountedRef.current = true\n    return () => {\n      isMountedRef.current = false\n    }\n  }, [])\n\n  const measure = useCallback(() => {\n    if (!open) {\n      setIsPositioned(false)\n      return\n    }\n\n    const anchor = anchorRef.current\n    const content = contentRef.current\n\n    if (!anchor || !content) {\n      return\n    }\n\n    // On web, views have a DOM node we can measure\n    // biome-ignore lint/suspicious/noExplicitAny: accessing web-specific DOM properties\n    const anchorElement = (anchor as any)._nativeTag ?? anchor\n    // biome-ignore lint/suspicious/noExplicitAny: accessing web-specific DOM properties\n    const contentElement = (content as any)._nativeTag ?? content\n\n    // Use getBoundingClientRect for precise measurements\n    let anchorDOMRect: DOMRect | undefined\n    let contentDOMRect: DOMRect | undefined\n\n    try {\n      // Try to get the actual DOM element\n      // biome-ignore lint/suspicious/noExplicitAny: accessing web-specific DOM properties\n      const getElement = (ref: any): HTMLElement | null => {\n        if (ref instanceof HTMLElement) {\n          return ref\n        }\n        if (ref && typeof ref.getBoundingClientRect === \"function\") {\n          return ref\n        }\n        // React Native Web stores DOM node differently\n        if (\n          ref?._nativeTag &&\n          typeof ref._nativeTag.getBoundingClientRect === \"function\"\n        ) {\n          return ref._nativeTag\n        }\n        return null\n      }\n\n      const anchorEl = getElement(anchorElement)\n      const contentEl = getElement(contentElement)\n\n      if (!anchorEl || !contentEl) {\n        // Fall back to measureInWindow if available (hybrid approach)\n        if (typeof anchor.measureInWindow === \"function\") {\n          anchor.measureInWindow(\n            (x: number, y: number, width: number, height: number) => {\n              if (!isMountedRef.current) return\n\n              if (width === 0 && height === 0) {\n                return\n              }\n\n              content.measureInWindow(\n                (_cx: number, _cy: number, cw: number, ch: number) => {\n                  if (!isMountedRef.current) return\n\n                  if (cw === 0 && ch === 0) {\n                    return\n                  }\n\n                  const anchorRect: Rect = { x, y, width, height }\n                  const contentRect: Rect = {\n                    x: 0,\n                    y: 0,\n                    width: cw,\n                    height: ch,\n                  }\n                  const viewport: Viewport = {\n                    width: window.innerWidth,\n                    height: window.innerHeight,\n                  }\n\n                  let computedPosition: Position\n                  let finalPlacement: Placement\n\n                  if (flip) {\n                    const result = applyFlip(\n                      anchorRect,\n                      contentRect,\n                      requestedPlacement,\n                      offset,\n                      alignOffset,\n                      viewport,\n                      collisionPadding,\n                    )\n                    computedPosition = result.position\n                    finalPlacement = result.placement\n                  } else {\n                    computedPosition = computePosition(\n                      anchorRect,\n                      contentRect,\n                      requestedPlacement,\n                      offset,\n                      alignOffset,\n                    )\n                    finalPlacement = requestedPlacement\n                  }\n\n                  computedPosition = constrainToViewport(\n                    computedPosition,\n                    contentRect,\n                    viewport,\n                    collisionPadding,\n                  )\n\n                  setPosition(computedPosition)\n                  setActualPlacement(finalPlacement)\n                  setIsPositioned(true)\n                },\n              )\n            },\n          )\n          return\n        }\n        return\n      }\n\n      anchorDOMRect = anchorEl.getBoundingClientRect()\n      contentDOMRect = contentEl.getBoundingClientRect()\n    } catch {\n      return\n    }\n\n    if (!anchorDOMRect || !contentDOMRect) {\n      return\n    }\n\n    const anchorRect: Rect = {\n      x: anchorDOMRect.left,\n      y: anchorDOMRect.top,\n      width: anchorDOMRect.width,\n      height: anchorDOMRect.height,\n    }\n\n    const contentRect: Rect = {\n      x: 0,\n      y: 0,\n      width: contentDOMRect.width,\n      height: contentDOMRect.height,\n    }\n\n    const viewport: Viewport = {\n      width: window.innerWidth,\n      height: window.innerHeight,\n    }\n\n    let computedPosition: Position\n    let finalPlacement: Placement\n\n    if (flip) {\n      const result = applyFlip(\n        anchorRect,\n        contentRect,\n        requestedPlacement,\n        offset,\n        alignOffset,\n        viewport,\n        collisionPadding,\n      )\n      computedPosition = result.position\n      finalPlacement = result.placement\n    } else {\n      computedPosition = computePosition(\n        anchorRect,\n        contentRect,\n        requestedPlacement,\n        offset,\n        alignOffset,\n      )\n      finalPlacement = requestedPlacement\n    }\n\n    // Constrain to viewport as final fallback\n    computedPosition = constrainToViewport(\n      computedPosition,\n      contentRect,\n      viewport,\n      collisionPadding,\n    )\n\n    setPosition(computedPosition)\n    setActualPlacement(finalPlacement)\n    setIsPositioned(true)\n  }, [\n    open,\n    anchorRef,\n    contentRef,\n    requestedPlacement,\n    offset,\n    alignOffset,\n    flip,\n    collisionPadding,\n  ])\n\n  // Measure when open state changes\n  useEffect(() => {\n    if (open) {\n      // Use requestAnimationFrame to ensure layout is complete\n      const rafId = requestAnimationFrame(() => {\n        measure()\n      })\n      return () => cancelAnimationFrame(rafId)\n    }\n    setIsPositioned(false)\n  }, [open, measure])\n\n  // Re-measure on resize and scroll\n  useEffect(() => {\n    if (!open) return\n\n    const handleResize = () => {\n      measure()\n    }\n\n    const handleScroll = () => {\n      measure()\n    }\n\n    window.addEventListener(\"resize\", handleResize, { passive: true })\n    window.addEventListener(\"scroll\", handleScroll, {\n      passive: true,\n      capture: true,\n    })\n\n    return () => {\n      window.removeEventListener(\"resize\", handleResize)\n      window.removeEventListener(\"scroll\", handleScroll, { capture: true })\n    }\n  }, [open, measure])\n\n  return {\n    position,\n    actualPlacement,\n    isPositioned,\n    update: measure,\n  }\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "lib/positioning/index.ts",
      "content": "// Platform-specific implementations are resolved via bundler:\n// - use-positioning.native.ts for iOS/Android\n// - use-positioning.web.ts for web\n\n// Re-export utilities for advanced usage\nexport {\n  applyFlip,\n  composePlacement,\n  computePosition,\n  constrainToViewport,\n  detectOverflow,\n  getOppositeSide,\n  parsePlacement,\n} from \"./positioning-utils\"\n\n// Re-export types\nexport type {\n  Alignment,\n  Placement,\n  Position,\n  PositioningResult,\n  Rect,\n  Side,\n  UsePositioningOptions,\n  Viewport,\n} from \"./types\"\nexport { usePositioning } from \"./use-positioning\"\n",
      "type": "registry:lib"
    }
  ]
}
