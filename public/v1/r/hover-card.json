{
  "name": "hover-card",
  "type": "registry:ui",
  "title": "Hover Card",
  "description": "Displays rich content when a trigger is hovered or focused.",
  "registryDependencies": [
    "@shadniwind/tokens",
    "@shadniwind/portal",
    "@shadniwind/overlay",
    "@shadniwind/positioning"
  ],
  "files": [
    {
      "path": "components/ui/hover-card.tsx",
      "content": "import * as React from \"react\"\nimport {\n  Platform,\n  Pressable,\n  type PressableProps,\n  type View,\n  type ViewProps,\n} from \"react-native\"\nimport { StyleSheet } from \"react-native-unistyles\"\nimport { DismissLayer } from \"../primitives/overlay/index\"\nimport { Portal } from \"../primitives/portal/index\"\nimport {\n  type Placement,\n  usePositioning,\n} from \"../primitives/positioning/index\"\n\nconst HOVER_CARD_OPEN_DELAY = 700\nconst HOVER_CARD_CLOSE_DELAY = 300\n\nfunction composeEventHandlers<E>(\n  originalEventHandler?: (event: E) => void,\n  ourEventHandler?: (event: E) => void,\n  { checkForDefaultPrevented = true } = {},\n) {\n  return function handleEvent(event: E) {\n    originalEventHandler?.(event)\n\n    if (\n      checkForDefaultPrevented === false ||\n      // @ts-expect-error - defaultPrevented check\n      !event?.defaultPrevented\n    ) {\n      return ourEventHandler?.(event)\n    }\n  }\n}\n\ntype HoverCardContextValue = {\n  open: boolean\n  onOpenChange: (open: boolean) => void\n  triggerRef: React.RefObject<View | null>\n  contentRef: React.RefObject<View | null>\n  scheduleOpen: () => void\n  scheduleClose: () => void\n  clearTimers: () => void\n  openDelay: number\n  closeDelay: number\n}\n\nconst HoverCardContext = React.createContext<HoverCardContextValue | undefined>(\n  undefined,\n)\n\nfunction useHoverCard() {\n  const context = React.useContext(HoverCardContext)\n  if (!context) {\n    throw new Error(\"HoverCard components must be used within HoverCard\")\n  }\n  return context\n}\n\nexport type HoverCardProps = {\n  children: React.ReactNode\n  defaultOpen?: boolean\n  open?: boolean\n  onOpenChange?: (open: boolean) => void\n  openDelay?: number\n  closeDelay?: number\n}\n\nexport function HoverCard({\n  children,\n  defaultOpen = false,\n  open: openProp,\n  onOpenChange,\n  openDelay = HOVER_CARD_OPEN_DELAY,\n  closeDelay = HOVER_CARD_CLOSE_DELAY,\n}: HoverCardProps) {\n  const [open, setOpen] = React.useState(defaultOpen)\n  const triggerRef = React.useRef<View>(null)\n  const contentRef = React.useRef<View>(null)\n  const openTimerRef = React.useRef<NodeJS.Timeout | undefined>(undefined)\n  const closeTimerRef = React.useRef<NodeJS.Timeout | undefined>(undefined)\n\n  const isControlled = openProp !== undefined\n  const isOpen = isControlled ? openProp : open\n\n  const handleOpenChange = React.useCallback(\n    (nextOpen: boolean) => {\n      if (!isControlled) {\n        setOpen(nextOpen)\n      }\n      onOpenChange?.(nextOpen)\n    },\n    [isControlled, onOpenChange],\n  )\n\n  const clearTimers = React.useCallback(() => {\n    if (openTimerRef.current) {\n      clearTimeout(openTimerRef.current)\n    }\n    if (closeTimerRef.current) {\n      clearTimeout(closeTimerRef.current)\n    }\n    openTimerRef.current = undefined\n    closeTimerRef.current = undefined\n  }, [])\n\n  const scheduleOpen = React.useCallback(() => {\n    if (isOpen) {\n      if (closeTimerRef.current) {\n        clearTimeout(closeTimerRef.current)\n      }\n      return\n    }\n\n    if (closeTimerRef.current) {\n      clearTimeout(closeTimerRef.current)\n    }\n    if (openDelay === 0) {\n      handleOpenChange(true)\n      return\n    }\n    if (openTimerRef.current) {\n      clearTimeout(openTimerRef.current)\n    }\n    openTimerRef.current = setTimeout(() => {\n      handleOpenChange(true)\n    }, openDelay)\n  }, [handleOpenChange, isOpen, openDelay])\n\n  const scheduleClose = React.useCallback(() => {\n    if (!isOpen) {\n      if (openTimerRef.current) {\n        clearTimeout(openTimerRef.current)\n      }\n      return\n    }\n\n    if (openTimerRef.current) {\n      clearTimeout(openTimerRef.current)\n    }\n    if (closeDelay === 0) {\n      handleOpenChange(false)\n      return\n    }\n    if (closeTimerRef.current) {\n      clearTimeout(closeTimerRef.current)\n    }\n    closeTimerRef.current = setTimeout(() => {\n      handleOpenChange(false)\n    }, closeDelay)\n  }, [closeDelay, handleOpenChange, isOpen])\n\n  React.useEffect(() => {\n    return () => clearTimers()\n  }, [clearTimers])\n\n  return (\n    <HoverCardContext.Provider\n      value={{\n        open: !!isOpen,\n        onOpenChange: handleOpenChange,\n        triggerRef,\n        contentRef,\n        scheduleOpen,\n        scheduleClose,\n        clearTimers,\n        openDelay,\n        closeDelay,\n      }}\n    >\n      {children}\n    </HoverCardContext.Provider>\n  )\n}\n\nexport type HoverCardTriggerProps = PressableProps & { asChild?: boolean }\n\nexport const HoverCardTrigger = React.forwardRef<\n  React.ComponentRef<typeof Pressable>,\n  HoverCardTriggerProps\n>(\n  (\n    {\n      children,\n      asChild,\n      onHoverIn,\n      onHoverOut,\n      onFocus,\n      onBlur,\n      onLongPress,\n      disabled,\n      ...props\n    },\n    ref,\n  ) => {\n    const { onOpenChange, triggerRef, scheduleOpen, scheduleClose } =\n      useHoverCard()\n    const isDisabled = !!disabled\n\n    const handleHoverIn = React.useCallback(\n      (event: unknown) => {\n        if (isDisabled) return\n        if (Platform.OS === \"web\") {\n          scheduleOpen()\n        }\n        // @ts-expect-error - Web event type\n        onHoverIn?.(event)\n      },\n      [isDisabled, onHoverIn, scheduleOpen],\n    )\n\n    const handleHoverOut = React.useCallback(\n      (event: unknown) => {\n        if (isDisabled) return\n        if (Platform.OS === \"web\") {\n          scheduleClose()\n        }\n        // @ts-expect-error - Web event type\n        onHoverOut?.(event)\n      },\n      [isDisabled, onHoverOut, scheduleClose],\n    )\n\n    const handleFocus = React.useCallback(\n      (event: unknown) => {\n        if (isDisabled) return\n        if (Platform.OS === \"web\") {\n          scheduleOpen()\n        }\n        // @ts-expect-error - Web event type\n        onFocus?.(event)\n      },\n      [isDisabled, onFocus, scheduleOpen],\n    )\n\n    const handleBlur = React.useCallback(\n      (event: unknown) => {\n        if (isDisabled) return\n        if (Platform.OS === \"web\") {\n          scheduleClose()\n        }\n        // @ts-expect-error - Web event type\n        onBlur?.(event)\n      },\n      [isDisabled, onBlur, scheduleClose],\n    )\n\n    const handleLongPress = React.useCallback(\n      (event: unknown) => {\n        if (isDisabled) return\n        onOpenChange(true)\n        // @ts-expect-error - Event type mismatch\n        onLongPress?.(event)\n      },\n      [isDisabled, onLongPress, onOpenChange],\n    )\n\n    const setTriggerRef = React.useCallback(\n      (node: View | null) => {\n        triggerRef.current = node\n        if (typeof ref === \"function\") {\n          ref(node)\n        } else if (ref) {\n          ;(ref as { current: View | null }).current = node\n        }\n      },\n      [ref, triggerRef],\n    )\n\n    if (asChild && React.isValidElement(children)) {\n      const child = children as React.ReactElement<{\n        onHoverIn?: (event: unknown) => void\n        onHoverOut?: (event: unknown) => void\n        onFocus?: (event: unknown) => void\n        onBlur?: (event: unknown) => void\n        onLongPress?: (event: unknown) => void\n      }>\n      const childOnHoverIn = isDisabled ? undefined : child.props.onHoverIn\n      const childOnHoverOut = isDisabled ? undefined : child.props.onHoverOut\n      const childOnFocus = isDisabled ? undefined : child.props.onFocus\n      const childOnBlur = isDisabled ? undefined : child.props.onBlur\n      const childOnLongPress = isDisabled ? undefined : child.props.onLongPress\n      // biome-ignore lint/suspicious/noExplicitAny: Cloning logic\n      return React.cloneElement(child as React.ReactElement<any>, {\n        ref: setTriggerRef,\n        onHoverIn: composeEventHandlers(childOnHoverIn, handleHoverIn),\n        onHoverOut: composeEventHandlers(childOnHoverOut, handleHoverOut),\n        onFocus: composeEventHandlers(childOnFocus, handleFocus),\n        onBlur: composeEventHandlers(childOnBlur, handleBlur),\n        onLongPress: composeEventHandlers(childOnLongPress, handleLongPress),\n        disabled: isDisabled,\n        ...props,\n      })\n    }\n\n    return (\n      <Pressable\n        ref={setTriggerRef}\n        onHoverIn={handleHoverIn}\n        onHoverOut={handleHoverOut}\n        onFocus={handleFocus}\n        onBlur={handleBlur}\n        onLongPress={handleLongPress}\n        disabled={disabled}\n        {...props}\n      >\n        {children}\n      </Pressable>\n    )\n  },\n)\n\nHoverCardTrigger.displayName = \"HoverCardTrigger\"\n\nexport type HoverCardContentProps = ViewProps & {\n  side?: Placement\n  sideOffset?: number\n  align?: \"start\" | \"center\" | \"end\"\n  alignOffset?: number\n  avoidCollisions?: boolean\n  dismissable?: boolean\n  onDismiss?: () => void\n  onHoverIn?: (event: unknown) => void\n  onHoverOut?: (event: unknown) => void\n}\n\nconst styles = StyleSheet.create((theme) => ({\n  content: {\n    zIndex: 50,\n    borderRadius: theme.radius.md,\n    borderWidth: 1,\n    borderColor: theme.colors.border,\n    backgroundColor: theme.colors.popover,\n    padding: theme.spacing[4],\n    shadowColor: theme.colors.foreground,\n    shadowOpacity: 0.1,\n    shadowRadius: 4,\n    elevation: 2,\n  },\n}))\n\nexport const HoverCardContent = React.forwardRef<View, HoverCardContentProps>(\n  (\n    {\n      children,\n      side = \"top\",\n      sideOffset = 4,\n      align = \"center\",\n      alignOffset = 0,\n      avoidCollisions = true,\n      dismissable = true,\n      onDismiss,\n      onHoverIn,\n      onHoverOut,\n      onFocus,\n      onBlur,\n      style,\n      ...props\n    },\n    ref,\n  ) => {\n    const {\n      open,\n      onOpenChange,\n      triggerRef,\n      contentRef,\n      scheduleOpen,\n      scheduleClose,\n      clearTimers,\n    } = useHoverCard()\n\n    const actualPlacement = align === \"center\" ? side : `${side}-${align}`\n\n    const { position, isPositioned } = usePositioning({\n      anchorRef: triggerRef,\n      contentRef,\n      placement: actualPlacement as Placement,\n      offset: sideOffset,\n      alignOffset,\n      flip: avoidCollisions,\n      open,\n    })\n\n    const handleDismiss = React.useCallback(() => {\n      clearTimers()\n      onOpenChange(false)\n      onDismiss?.()\n    }, [clearTimers, onDismiss, onOpenChange])\n\n    const handleHoverIn = React.useCallback(\n      (event: unknown) => {\n        if (Platform.OS === \"web\") {\n          scheduleOpen()\n        }\n        onHoverIn?.(event)\n      },\n      [onHoverIn, scheduleOpen],\n    )\n\n    const handleHoverOut = React.useCallback(\n      (event: unknown) => {\n        if (Platform.OS === \"web\") {\n          scheduleClose()\n        }\n        onHoverOut?.(event)\n      },\n      [onHoverOut, scheduleClose],\n    )\n\n    const handleFocus = React.useCallback(\n      (event: unknown) => {\n        if (Platform.OS === \"web\") {\n          scheduleOpen()\n        }\n        // @ts-expect-error - Web event type\n        onFocus?.(event)\n      },\n      [onFocus, scheduleOpen],\n    )\n\n    const handleBlur = React.useCallback(\n      (event: unknown) => {\n        if (Platform.OS === \"web\") {\n          scheduleClose()\n        }\n        // @ts-expect-error - Web event type\n        onBlur?.(event)\n      },\n      [onBlur, scheduleClose],\n    )\n\n    const setContentRef = React.useCallback(\n      (node: View | null) => {\n        contentRef.current = node\n        if (typeof ref === \"function\") {\n          ref(node)\n        } else if (ref) {\n          ;(ref as { current: View | null }).current = node\n        }\n      },\n      [contentRef, ref],\n    )\n\n    if (!open) return null\n\n    return (\n      <Portal>\n        <DismissLayer onDismiss={handleDismiss} dismissable={dismissable}>\n          <Pressable\n            ref={setContentRef}\n            onHoverIn={handleHoverIn}\n            onHoverOut={handleHoverOut}\n            onFocus={handleFocus}\n            onBlur={handleBlur}\n            style={[\n              styles.content,\n              {\n                position: \"absolute\",\n                opacity: isPositioned ? 1 : 0,\n                top: position.top,\n                left: position.left,\n              },\n              style,\n            ]}\n            {...props}\n          >\n            {children}\n          </Pressable>\n        </DismissLayer>\n      </Portal>\n    )\n  },\n)\n\nHoverCardContent.displayName = \"HoverCardContent\"\n",
      "type": "registry:ui"
    }
  ]
}
